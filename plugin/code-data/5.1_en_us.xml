<?xml version="1.0"?>

<codedata lang="en_us" version="5.1">
   <keywords>
      <keyword name="nil" />
      <keyword name="while" />
      <keyword name="if" />
      <keyword name="else" />
      <keyword name="print" />
      <keyword name="break" />
      <keyword name="continue" />
      <keyword name="return" />
      <keyword name="sub" />
   </keywords>

   <groups>
      <group name="connection">
         <description>Generic functions that affect the current connection.</description>
         <functions>
            <func name="connection.close">
               <parameters min="1" max="2" regex=".|..">
                  <param name="Data" />
                  <param name="Read" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.close() writes the provided data directly back to the client. After the data has been sent, the connection is closed. &lt;/p&gt;&lt;p&gt; The optional second argument specifies whether ZXTM should continue to read in data from the client after sending this response, and wait for it to close the connection. If set to 0, ZXTM will close the connection immediately. If non-zero, ZXTM will wait and read any remaining data from the connection before closing it. &lt;/p&gt;&lt;p&gt; The default behaviour is to wait, because some client software will not read a response until it has sent its entire request. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.discard" />
                  <related func="http.sendResponse" />
               </relatedFunctions>
            </func>
            <func name="connection.discard">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; connection.discard() immediately closes the current connection and stops processing rules. This is equivalent to the function call 'pool.use( "discard" )'. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.close" />
                  <related func="http.sendResponse" />
               </relatedFunctions>
            </func>
            <func name="connection.getBandwidthClass">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_BW" />
                  <restriction type="ZXTM_TCP" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getBandwidthClass() gets the current bandwidth class for the connection to the client. It will return an empty string if no class is set. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by response.getBandwidthClass&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getBandwidthClass" />
                  <related func="request.getBandwidthClass" />
               </relatedFunctions>
            </func>
            <func name="connection.getData">
               <parameters min="1" max="1" regex=".">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getData() returns the first 'count' bytes of data provided by the client. &lt;/p&gt;&lt;p&gt; Warning: you can stall a connection by asking it to read more data than the remote client will provide. Combine this with connection.getDataLen() to reliably read data from a connection. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.get&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getDataLen" />
               </relatedFunctions>
            </func>
            <func name="connection.getDataLen">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getDataLen() returns the amount of data already received from the client. This can be combined with connection.getData() to reliably read data from a connection without stalling if no data is available. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.getLength&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getData" />
               </relatedFunctions>
            </func>
            <func name="connection.getLine">
               <parameters min="1" max="1" regex=".">
                  <param name="offset" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getLine() returns a line of input data provided by the client. The line separator is '\n', and this is stripped off before returning the line. connection.getline() takes a single byte-count argument which informs ZXTM where to start scanning for a line; a value of '0' begins at the start, so returns the first line. &lt;/p&gt;&lt;p&gt; When connection.getline() returns, the variable $1 is updated to point to the start of the next line in the datastream. &lt;/p&gt;&lt;p&gt; You can iterate through the lines of input data by using $1 as the iterator variable. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.getLine&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getData" />
               </relatedFunctions>
            </func>
            <func name="connection.getLocalIP">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getLocalIP() returns the IP address that the client connected to, i.e. the address local to this machine. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.getLocalIP&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getLocalPort" />
                  <related func="connection.getRemoteIP" />
                  <related func="connection.getRemotePort" />
               </relatedFunctions>
            </func>
            <func name="connection.getLocalPort">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getLocalPort returns the network port number that the client connected to. (e.g. port 80 is normal for a web server) &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.getLocalPort&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getLocalIP" />
                  <related func="connection.getRemoteIP" />
                  <related func="connection.getRemotePort" />
               </relatedFunctions>
            </func>
            <func name="connection.getMemoryUsage">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.getMemoryUsage() returns an estimate of the amount of memory currently in use for this connection, in bytes. Memory is primarily used for buffering data, and the memory usage can be tuned using the various buffer size settings. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="connection.getNode">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.getNode() returns the name of the back-end node that this connection is connected to. If a back-end node has not been chosen, which is normally the case in request rules, it returns the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getPool" />
                  <related func="connection.getVirtualServer" />
                  <related func="request.avoidNode" />
               </relatedFunctions>
            </func>
            <func name="connection.getPersistence">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.getPersistence returns the name of the current Session Persistence class that will be used for this connection. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.setPersistence" />
               </relatedFunctions>
            </func>
            <func name="connection.getPool">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.getPool() returns the name of the pool that this connection is connected to. If a pool has not been chosen, it returns the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getNode" />
                  <related func="connection.getVirtualServer" />
               </relatedFunctions>
            </func>
            <func name="connection.getRemoteIP">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getRemoteIP returns the remote IP address of the client. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.getRemoteIP&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getRemotePort" />
                  <related func="connection.getLocalIP" />
                  <related func="connection.getLocalPort" />
               </relatedFunctions>
            </func>
            <func name="connection.getRemotePort">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.getRemotePort() returns the remote port of the client's connection. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.getRemotePort&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getRemoteIP" />
                  <related func="connection.getLocalIP" />
                  <related func="connection.getLocalPort" />
               </relatedFunctions>
            </func>
            <func name="connection.getServiceLevelClass">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SLM" />
               </restrictions>
               <description>&lt;p&gt; connection.getServiceLevelClass gets the current service level class for the connection. It will return an empty string if no class is set. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.setServiceLevelClass" />
               </relatedFunctions>
            </func>
            <func name="connection.getVirtualServer">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.getVirtualServer() returns the name of the Virtual Server that the rule is running under. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getNode" />
                  <related func="connection.getPool" />
               </relatedFunctions>
            </func>
            <func name="connection.setBandwidthClass">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_BW" />
                  <restriction type="ZXTM_TCP" />
                  <restriction type="ZXTM_RB" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.setBandwidthClass() sets the bandwidth class for the current connection to the client. Providing an empty class name removes the bandwidth class from the connection. It returns zero if an error occurs (for example, if the bandwidth class does not exist), and 1 otherwise. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by response.setBandwidthClass&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.setBandwidthClass" />
                  <related func="request.setBandwidthClass" />
               </relatedFunctions>
            </func>
            <func name="connection.setData">
               <parameters min="1" max="1" regex=".">
                  <param name="request data" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.setData() replaces the input data read from the client with the provided string. &lt;/p&gt;&lt;p&gt; This is a low-level routine that should be used with care. For protocols with their own higher-level protocol managers (e.g. http), use the higher level routines to alter the input data (e.g. http.setHeader() and http.setBody()). &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.set&lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="connection.setIdempotent">
               <parameters min="1" max="1" regex=".">
                  <param name="resend" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; connection.setIdempotent() marks a request as resendable or non-resendable. &lt;/p&gt;&lt;p&gt; An &lt;i&gt;idempotent&lt;/i&gt; request has no detrimental side effects, so it can safely be attempted multiple times. A non-idempotent request has a side effect - for example, it may update a database, or initiate a purchase. &lt;/p&gt;&lt;p&gt; By default, all non-HTTP requests are marked as idempotent. If a back-end node fails to generate a correct response when a request is initially forwarded to it, ZXTM will attempt to resend the request to another node. &lt;/p&gt;&lt;p&gt; connection.setIdempotent() can override this behaviour. If 'resend' is zero, this indicates that the request should only be attempted against one back-end node. &lt;/p&gt;&lt;p&gt; If 'resend' has a non-zero value, this indicates that if a request is made to a back-end node and a correct response is not received, ZXTM should retry the request against another back-end node. &lt;/p&gt;&lt;p&gt; Note that ZXTM cannot resend a request once has begun streaming data between the client and the node. Additionally, UDP connections cannot be marked as resendable (the UDP client application should handle failed UDP responses). &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by request.setIdempotent&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setIdempotent" />
               </relatedFunctions>
            </func>
            <func name="connection.setPersistence">
               <parameters min="0" max="1" regex=".?">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; connection.setPersistence sets the Session Persistence class that will be used for the connection. This is used to override the default Session Persistence class that will be used once a Pool is selected. &lt;/p&gt;&lt;p&gt; If no parameter is given then Session Persistence class will be removed and the Pool's (when it is selected) default session persistence class will be used for this connection. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getPersistence" />
                  <related func="connection.setPersistenceKey" />
               </relatedFunctions>
            </func>
            <func name="connection.setPersistenceKey">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.setPersistenceKey sets the value of the Session Persistence key that is used by a Universal Session Persistence type class. &lt;/p&gt;&lt;p&gt; A Session Persistence class that uses Universal Session Persistence attempts to ensure that every connection that provides the same key is directed to the same back-end node. &lt;/p&gt;&lt;p&gt; This function has no effect if a different type of session persistence class is ultimately used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.setPersistence" />
               </relatedFunctions>
            </func>
            <func name="connection.setPersistenceNode">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.setPersistenceNode sets the back-end node to be used by a NamedNode Persistence class. &lt;/p&gt;&lt;p&gt; A Session Persistence class that uses NamedNode Persistence will then ensure that this node will be used for the request. The node must be valid and exist in the Pool being used. If no port number is given, or if the port number is not valid, then if there is a node with a matching name, it will be used. For example, if the node 'web:80' is specified, but there is only a 'web:443', then that node will be used instead. This is to help share session persistence between different services on the same machine. &lt;/p&gt;&lt;p&gt; This function has no effect if a different type of session persistence class is ultimately used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.setPersistence" />
               </relatedFunctions>
            </func>
            <func name="connection.setServiceLevelClass">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SLM" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; connection.setServiceLevelClass sets the service level class for the current connection. It returns zero if an error occurs (for example, if the service level class does not exist), and 1 otherwise &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.getServiceLevelClass" />
               </relatedFunctions>
            </func>
            <func name="connection.sleep">
               <parameters min="1" max="1" regex=".">
                  <param name="milliseconds" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.sleep() pauses processing of the current connection for the specified number of milliseconds. This can be used to rate-limit particular clients; for example, those asking for particular files, or from particular locations, or using particular user-agents. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="connection.data">
         <description>Functions that allow you to store and retrieve data stored for the lifetime of the current connection.</description>
         <functions>
            <func name="connection.data.get">
               <parameters min="1" max="1" regex=".">
                  <param name="key" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.data.get() returns the value that was previously stored with the given key using connection.data.set() in the current connection, or returns the empty string if no data was stored. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.data.set" />
                  <related func="data.get" />
               </relatedFunctions>
            </func>
            <func name="connection.data.set">
               <parameters min="2" max="2" regex="..">
                  <param name="key" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; connection.data.set() stores a value for this connection, associating it with the provided key. The value can be retrieved later when processing the same connection, using connection.data.get(). Once the connection finishes, the value cannot be retrieved. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.data.get" />
                  <related func="data.set" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="counter">
         <description>Functions for altering user defined counters.</description>
         <functions>
            <func name="counter.increment">
               <parameters min="1" max="2" regex=".|..">
                  <param name="counter" />
                  <param name="amount" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; counter.increment increments the numbered counter. These counters are readable via SNMP, and can be graphed on the Current Activity page on the Administration Server. &lt;/p&gt;&lt;p&gt; By default, the counter is incremented by one, but you can also supply a number to increment the counter by. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="data">
         <description>Functions that allow you to store information shared between all rules.</description>
         <functions>
            <func name="data.get">
               <parameters min="1" max="1" regex=".">
                  <param name="key" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; data.get() returns the value that was previously stored with the given key using data.set(), or returns the empty string if no data was stored. &lt;/p&gt;&lt;p&gt; Values stored in this way are persistent; a value stored in one rule can later be retrieved by a different rule handling a different connection. Thus, a rule can maintain persistent state across connections. &lt;/p&gt;&lt;p&gt; &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="data.set" />
                  <related func="data.remove" />
                  <related func="data.getMemoryUsage" />
               </relatedFunctions>
            </func>
            <func name="data.getMemoryUsage">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; data.getMemoryUsage() returns an estimate of the amount of memory, in bytes, used by entries that have been stored by data.set(). &lt;/p&gt;&lt;p&gt; This can be used to verify if a rule is storing excessive amounts of data, starving the host machine of memory. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="data.set" />
                  <related func="data.reset" />
               </relatedFunctions>
            </func>
            <func name="data.remove">
               <parameters min="1" max="1" regex=".">
                  <param name="key" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; data.remove() removes the value that was previously associated with the given key using data.set(). &lt;/p&gt;&lt;p&gt; data.remove() returns 1 if the item did exist, or 0 if it was not found. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="data.set" />
                  <related func="data.get" />
                  <related func="data.reset" />
               </relatedFunctions>
            </func>
            <func name="data.reset">
               <parameters min="0" max="1" regex=".?">
                  <param name="prefix" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; data.reset() removes some or all of the mappings created by data.set(). With no arguments, it removes all keys. With a single argument, it removes all keys that begin with the supplied string. &lt;/p&gt;&lt;p&gt; &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="data.set" />
                  <related func="data.remove" />
                  <related func="data.getMemoryUsage" />
               </relatedFunctions>
            </func>
            <func name="data.set">
               <parameters min="2" max="2" regex="..">
                  <param name="key" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; data.set() stores a value persistently, associating it with the provided key. The value can be retrieved later using data.get(), even from a different rule or connection. &lt;/p&gt;&lt;p&gt; The value will be stored as a string, implicit conversion of floating point numbers to strings can cause some precision loss. You can convert a floating point number into a string with no precision loss using 'string.sprintf( "%f", $val )'. &lt;/p&gt;&lt;p&gt; To prevent memory problems, there is an upper limit on the amount of data that can be stored in the TrafficScript data storage. This means that the data.set() may fail. The upper limit can be configured using trafficscript!data_size on the Global Settings page. &lt;/p&gt;&lt;p&gt; data.set() returns 1 if the entry was stored, or 0 if there was no room. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="data.get" />
                  <related func="data.remove" />
                  <related func="data.getMemoryUsage" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="event">
         <description>Functions to generate custom events.</description>
         <functions>
            <func name="event.emit">
               <parameters min="2" max="2" regex="..">
                  <param name="custom event name" />
                  <param name="message" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; event.emit triggers a Custom Event identified by a 'custom event name'. Actions can be associated with the Custom Event by configuring an Event Type to contain a Custom Event with the specified 'custom event name', and then associating that Event Type with an Action. &lt;/p&gt;&lt;p&gt; The 'custom event name' should contain plain ASCII characters, and cannot contain '/'. &lt;/p&gt;&lt;p&gt; In addition to custom actions, a log message will be produced containing the eventid and the message. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="log.info" />
                  <related func="log.warn" />
                  <related func="log.error" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="http">
         <description>HTTP protocol-specific functions.</description>
         <functions>
            <func name="http.addHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.addHeader() modifies the current HTTP request, adding an HTTP header with the supplied value. If the header already exists, then this value will be appended to the existing value. The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setHeader" />
                  <related func="http.getHeader" />
                  <related func="http.removeHeader" />
                  <related func="http.headerExists" />
                  <related func="http.addResponseHeader" />
               </relatedFunctions>
            </func>
            <func name="http.addResponseHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.addResponseHeader() adds an HTTP header to the HTTP response that will be sent back to the client. If the header already exists in the response, then this value will be appended to the existing value. The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setResponseHeader" />
                  <related func="http.getResponseHeader" />
                  <related func="http.removeResponseHeader" />
                  <related func="http.addHeader" />
               </relatedFunctions>
            </func>
            <func name="http.changeSite">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.changeSite() can be used to redirect users to a new website. It is a more sophisticated version of http.redirect(), that will preserve the original path that the request asked for. For instance, if the original request was for 'http://www.example.com/image/image.jpg', then http.changeSite( "example.co.uk" ) would redirect the user to 'http://example.co.uk/image/image.jpg' The redirection will preserve the original path (and any query string) of the request, together with the port number and protocol. If you wish to force any of these details, then you can specify them as part of the supplied host name. e.g. http.changeSite( "https://www.example.com" ) will always send people to a SSL-encrypted site. You can also add on a prefix to the path of the URL, e.g. http.changeSite( "www.example.com/oldsite" ) would redirect a request for 'http://www.example.com/missing/page.html' to 'http://www.example.com/oldsite/missing/page.html'. If the original request matches the supplied redirection, then http.changeSite() will take no action and let the request continue. This ensures that no 'redirection loops' occur. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.sendResponse" />
                  <related func="http.redirect" />
               </relatedFunctions>
            </func>
            <func name="http.cookie">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; http.cookie() returns the value of the named cookie. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by http.getCookie&lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getCookie" />
               </relatedFunctions>
            </func>
            <func name="http.doesFormParamExist">
               <parameters min="1" max="1" regex=".">
                  <param name="Parameter" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.doesFormParamExist() checks whether a form parameter is present, either in the URL query string, or if not found and the request is a POST, from the POST body data. It returns 1 if the parameter is present, and 0 if not.&lt;/p&gt;&lt;p&gt; This is useful when there are form parameters with no value, e.g a query string like 'foo=bar&amp;stuff&amp;x=y' - the 'stuff' parameter has no value, but is present. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getFormParam" />
               </relatedFunctions>
            </func>
            <func name="http.getBody">
               <parameters min="0" max="1" regex=".?">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getBody() returns the body data of the request. &lt;/p&gt;&lt;p&gt; If the optional 'count' parameter is supplied, http.getBody() will only read and return this number of bytes. If count is 0, http.getBody() returns the entire request. &lt;/p&gt;&lt;p&gt; If the request has no body, then this returns an empty string. This function is not useable in response rules, as the body data of the request will no longer be accessible. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setBody" />
                  <related func="http.getResponseBody" />
               </relatedFunctions>
            </func>
            <func name="http.getCookie">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getCookie() returns the value of the named cookie in the incoming HTTP request. &lt;/p&gt;&lt;p&gt; http.getCookie is a helper method that makes it easier to parse the HTTP Cookie header and extract the values of that particular cookie, rather than using http.getHeader() directly. &lt;/p&gt;&lt;p&gt; An HTTP 'Cookie' header can have multiple values, such as &lt;/p&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;Cookie: user-id=Joe; user-type=gold &lt;/p&gt;&lt;p&gt; http.getCookie( ... ) will retrieve the 'Cookie' header line and parse it, returning the value of the cookie. If the cookie does not exist, http.getCookie() will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setCookie" />
                  <related func="http.removeCookie" />
                  <related func="http.getResponseCookie" />
               </relatedFunctions>
            </func>
            <func name="http.getFormParam">
               <parameters min="1" max="2" regex="..?">
                  <param name="Parameter" />
                  <param name="Separator" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getFormParam() returns the %-decoded form parameter from the URL query string, or if not found and the request is a POST, from the POST body data. &lt;/p&gt;&lt;p&gt; If the parameter is provided twice, only the first will be returned, unless the optional Separator is provided, in which case all matches will be returned, separated with this string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setQueryString" />
                  <related func="http.getRawURL" />
                  <related func="http.getBody" />
               </relatedFunctions>
            </func>
            <func name="http.getHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getHeader() returns the value of a named HTTP header in the HTTP request, or the empty string if the header does not exist or has an empty value. The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setHeader" />
                  <related func="http.addHeader" />
                  <related func="http.removeHeader" />
                  <related func="http.headerExists" />
                  <related func="http.getResponseHeader" />
                  <related func="http.getHostHeader" />
               </relatedFunctions>
            </func>
            <func name="http.getHeaderNames">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getHeaderNames() returns a list of all the headers that are present in the request. &lt;/p&gt;&lt;p&gt; The headers are returned as a single string, separated by spaces. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getHeader" />
                  <related func="http.removeHeader" />
                  <related func="http.getRequest" />
                  <related func="http.getResponseHeaderNames" />
               </relatedFunctions>
            </func>
            <func name="http.getHostHeader">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getHostHeader() returns the HTTP Host header. This value is lowercased and has the port removed. Any trailing full stop is also removed. For example if the Host header is 'www.Zeus.com:80' then http.getHostHeader() returns 'www.zeus.com'. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getHeader" />
               </relatedFunctions>
            </func>
            <func name="http.getMethod">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getMethod() returns the HTTP method that was used to make the request, such as GET or POST. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setMethod" />
               </relatedFunctions>
            </func>
            <func name="http.getMultipartAttachment">
               <parameters min="1" max="1" regex=".">
                  <param name="part" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getMultipartAttachment() gets the specified data out of a multipart encoded HTTP request. The data contained in the part is returned on success, or "" if it doesn't exist for that part. $1 contains the Content Type of the part, and $2 contains the complete headers for that part. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="http.getPath">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getPath() returns the %-decoded path in the HTTP request URL, stripping the query string if one was provided. If there is a leading scheme and authority prefix, this is removed as well, so a raw url of 'http://www.example.com/content?page=44' will be returned as '/content'. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setPath" />
                  <related func="http.getRawURL" />
                  <related func="http.getQueryString" />
                  <related func="http.getRawQueryString" />
                  <related func="http.normalizePath" />
               </relatedFunctions>
            </func>
            <func name="http.getQueryString">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getQueryString() returns the %-decoded query string in the URL, or the empty string if no query string was provided. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setQueryString" />
                  <related func="http.getRawQueryString" />
                  <related func="http.setRawQueryString" />
                  <related func="http.getRawURL" />
               </relatedFunctions>
            </func>
            <func name="http.getRawQueryString">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getRawQueryString() returns the raw query string in the URL, or the empty string if no query string was provided. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setRawQueryString" />
                  <related func="http.getQueryString" />
                  <related func="http.setQueryString" />
                  <related func="http.getRawURL" />
               </relatedFunctions>
            </func>
            <func name="http.getRawURL">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getRawURL() returns the raw URL data provided by the client in the first line of the HTTP request, after the method and before the HTTP version specifier. &lt;/p&gt;&lt;p&gt; The raw URL data includes both the path and query string if supplied and is not decoded. It may also contain the protocol and hostname if the client sent them. It could contain %-escaped characters that can be used to disguise the contents of the URL. Use http.getPath() or http.getQueryString() to return the %-decoded version of the path or query string. &lt;/p&gt;&lt;p&gt; This function could return raw urls of various forms including: &lt;ul&gt; &lt;li&gt;http://www.example.com/file.html&lt;/li&gt; &lt;li&gt;/file.html&lt;/li&gt; &lt;li&gt;/path/../file.html&lt;/li&gt; &lt;li&gt;/file.html?querystring&lt;/li&gt; &lt;li&gt;/file.html?qs%encoded&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt;&lt;p&gt; You can use http.normalizePath() on the path component to remove any '/../' or '/./' references. &lt;/p&gt;&lt;p&gt; In general it is better to use http.getPath() and http.getQueryString() to avoid the need to process the raw url. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getPath" />
                  <related func="http.getQueryString" />
                  <related func="http.getRawQueryString" />
                  <related func="string.unescape" />
                  <related func="http.normalizePath" />
               </relatedFunctions>
            </func>
            <func name="http.getRequest">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getRequest() returns the full HTTP request and headers, but does not include any body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getHeaderNames" />
                  <related func="http.getHeader" />
                  <related func="http.getBody" />
               </relatedFunctions>
            </func>
            <func name="http.getResponse">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getResponse() returns the beginning of the HTTP response (the status line and the headers), up to but not including the empty line that separates the headers from the body. The returned string does not include any body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseHeaderNames" />
                  <related func="http.getResponseHeader" />
                  <related func="http.getResponseBody" />
               </relatedFunctions>
            </func>
            <func name="http.getResponseBody">
               <parameters min="0" max="1" regex=".?">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getResponseBody() returns the body of the HTTP response. &lt;/p&gt;&lt;p&gt; If the optional 'count' parameter is provided, http.getResponseBody() will read and return the first 'count' bytes of the response. If count is 0, http.getResponseBody() will return the entire response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setResponseBody" />
                  <related func="http.getBody" />
               </relatedFunctions>
            </func>
            <func name="http.getResponseCode">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getResponseCode() returns the status code from the first line of the HTTP response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setResponseCode" />
               </relatedFunctions>
            </func>
            <func name="http.getResponseCookie">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getResponseCookie() returns the value of the named cookie in the HTTP response. &lt;/p&gt;&lt;p&gt; http.getResponseCookie is a helper method to make it easier to parse the HTTP Set-Cookie header and extract the values of that particular cookie, rather than using http.getResponseHeader() directly. &lt;/p&gt;&lt;p&gt; If the cookie does not exist, http.getResponseCookie() will return the empty string. &lt;/p&gt;&lt;p&gt; This function should be called in a response rule; it has no effect in a request rule. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setResponseCookie" />
                  <related func="http.removeResponseCookie" />
                  <related func="http.getCookie" />
               </relatedFunctions>
            </func>
            <func name="http.getResponseHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getResponseHeader() returns the value of a named HTTP header in the HTTP response, or the empty string if the header does not exist or has an empty value. The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setResponseHeader" />
                  <related func="http.addResponseHeader" />
                  <related func="http.removeResponseHeader" />
                  <related func="http.responseHeaderExists" />
                  <related func="http.getHeader" />
               </relatedFunctions>
            </func>
            <func name="http.getResponseHeaderNames">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getResponseHeaderNames() returns a list of all the headers that are present in the response. &lt;/p&gt;&lt;p&gt; The headers are returned as a single string, separated by spaces. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseHeader" />
                  <related func="http.removeResponseHeader" />
                  <related func="http.getResponse" />
                  <related func="http.getHeaderNames" />
               </relatedFunctions>
            </func>
            <func name="http.getResponseVersion">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.getResponseVersion() returns the version of the HTTP protocol being used. It returns the version string in the first line of the HTTP response, such as 'HTTP/1.1'. It will return the empty string in the case of HTTP/0.9 response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getVersion" />
               </relatedFunctions>
            </func>
            <func name="http.getVersion">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.getVersion() returns the version of the HTTP protocol being used. It returns the version string in the first line of the HTTP request, such as 'HTTP/1.1'. It will return the empty string in the case of HTTP/0.9, which does not have a version specifier in the request. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseVersion" />
               </relatedFunctions>
            </func>
            <func name="http.headerExists">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.headerExists() determines if a named header exists or not. It is similar to http.getHeader(), but makes it possible to distinguish between a header not being present and a header having no value. &lt;/p&gt;&lt;p&gt; The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;&lt;p&gt; It returns 1 if the header exists, and 0 if it does not. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getHeader" />
               </relatedFunctions>
            </func>
            <func name="http.normalizePath">
               <parameters min="1" max="1" regex=".">
                  <param name="url" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.normalizePath() flattens a decoded URL path, converting '//' to '/', '/./' to '/', and flattening '/a/../' to '/'. It returns the flattened path string. &lt;/p&gt;&lt;p&gt; If the file system path is invalid, this function returns the empty string. Invalid paths include those that contain disallowed characters like '\0', invalid hex-escapes, or that use '../' sequences to reference a location outside the local root. &lt;/p&gt;&lt;p&gt; This function should be used on the retrieved URL before attempting path matching for access control. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getRawURL" />
               </relatedFunctions>
            </func>
            <func name="http.redirect">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.redirect() sends back a HTTP 302 redirect response, which will send a web browser to a different URL. This is equivalent to http.sendResponse( "302 Moved Temporarily", "text/html", "", "Location: " . $url ); &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.sendResponse" />
                  <related func="http.changeSite" />
               </relatedFunctions>
            </func>
            <func name="http.removeCookie">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.removeCookie() removes the named cookie from the incoming HTTP request. &lt;/p&gt;&lt;p&gt; http.removeCookie is a helper method that makes it easier to parse the HTTP Cookie header and remove a particular cookie, rather than using http.getHeader() and http.setHeader() directly. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getCookie" />
                  <related func="http.setCookie" />
                  <related func="http.removeResponseCookie" />
               </relatedFunctions>
            </func>
            <func name="http.removeHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.removeHeader() removes a named header if it exists in the request. The header name is automatically translated to the correct case. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getHeader" />
                  <related func="http.addHeader" />
                  <related func="http.setHeader" />
                  <related func="http.removeResponseHeader" />
               </relatedFunctions>
            </func>
            <func name="http.removeResponseCookie">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.removeResponseCookie() removes the named cookie from the HTTP response. &lt;/p&gt;&lt;p&gt; http.removeResponseCookie is a helper method, to avoid using http.removeResponseHeader() directly. It operates correctly when there are multiple Set-Cookie headers in the response. &lt;/p&gt;&lt;p&gt; This function should be called in a response rule; it has no effect in a request rule. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseCookie" />
                  <related func="http.setResponseCookie" />
                  <related func="http.removeCookie" />
               </relatedFunctions>
            </func>
            <func name="http.removeResponseHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.removeResponseHeader() removes the named HTTP header from the HTTP response. The header name is automatically translated to the correct case. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setResponseHeader" />
                  <related func="http.getResponseHeader" />
                  <related func="http.addResponseHeader" />
                  <related func="http.scrubResponseHeaders" />
                  <related func="http.removeHeader" />
               </relatedFunctions>
            </func>
            <func name="http.responseHeaderExists">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.responseHeaderExists() determines if a named header exists in the HTTP response. It is similar to http.getResponseHeader(), but makes it possible to distinguish between a header not being present and a header having no value. &lt;/p&gt;&lt;p&gt; The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;&lt;p&gt; It returns 1 if the header exists, and 0 if it does not. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseHeader" />
               </relatedFunctions>
            </func>
            <func name="http.scrubRequestHeaders">
               <parameters min="1" max="INF" regex=".+">
                  <param name="header1" />
                  <param name="header2" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.scrubRequestHeaders() limits the allowed HTTP request headers to a known set. The allowed headers can either be passed in as a list or space separated in a single argument. &lt;/p&gt;&lt;p&gt; Care should be taken when using this function to ensure that the headers that are required for connection handling are let through. At the very least, the following should be allowed: &lt;blockquote&gt; &lt;tt&gt;Connection&lt;/tt&gt;, &lt;tt&gt;Content-Length&lt;/tt&gt;, &lt;tt&gt;Transfer-Encoding&lt;/tt&gt;, &lt;tt&gt;Content-Type&lt;/tt&gt;, &lt;tt&gt;Host&lt;/tt&gt; &lt;/blockquote&gt; For a complete list of HTTP headers, refer to RFC2616. Protocols that extend HTTP, such as WebDAV, use other headers. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.removeHeader" />
                  <related func="http.scrubResponseHeaders" />
               </relatedFunctions>
            </func>
            <func name="http.scrubResponseHeaders">
               <parameters min="1" max="INF" regex=".+">
                  <param name="header1" />
                  <param name="header2" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.scrubResponseHeaders() limits the allowed HTTP response headers to a known set. The allowed headers can either be passed in as a list or space separated in a single argument. &lt;/p&gt;&lt;p&gt; Care should be taken when using this function to ensure that the headers that are required for connection handling are let through. At the very least, the following should be allowed: &lt;blockquote&gt; &lt;tt&gt;Connection&lt;/tt&gt;, &lt;tt&gt;Content-Length&lt;/tt&gt;, &lt;tt&gt;Transfer-Encoding&lt;/tt&gt;, &lt;tt&gt;Location&lt;/tt&gt; &lt;/blockquote&gt; For a complete list of HTTP headers, refer to RFC2616. Protocols that extend HTTP, such as WebDAV, use other headers. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.removeResponseHeader" />
                  <related func="http.scrubRequestHeaders" />
               </relatedFunctions>
            </func>
            <func name="http.sendResponse">
               <parameters min="4" max="4" regex="....">
                  <param name="code" />
                  <param name="type" />
                  <param name="body" />
                  <param name="headers" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.sendResponse() sends back an HTTP response to the client instead of balancing the request via a pool onto a node. It generates a correct HTTP response from the response code, content type, body data and headers supplied. Multiple headers should be separated with \r\n. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.close" />
                  <related func="connection.discard" />
               </relatedFunctions>
            </func>
            <func name="http.setBody">
               <parameters min="1" max="1" regex=".">
                  <param name="body" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.setBody() sets the request body for this HTTP request to the supplied string, replacing any request body already present. &lt;/p&gt;&lt;p&gt; This also updates the 'Content-Length' header in the request to the length of the new body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getBody" />
                  <related func="http.setResponseBody" />
               </relatedFunctions>
            </func>
            <func name="http.setCookie">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.setCookie() sets the value of the named cookie in the incoming HTTP request. &lt;/p&gt;&lt;p&gt; http.setCookie is a helper method that makes it easier to parse the HTTP Cookie header and set the value of a particular cookie, rather than using http.getHeader() and http.setHeader() directly. &lt;/p&gt;&lt;p&gt; An HTTP 'Cookie' header can have multiple values, such as &lt;/p&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;Cookie: user-id=Joe; user-type=gold &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getCookie" />
                  <related func="http.removeCookie" />
                  <related func="http.setResponseCookie" />
               </relatedFunctions>
            </func>
            <func name="http.setHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.setHeader() sets the value of the named HTTP header, replacing any existing value if the header already exists. &lt;/p&gt;&lt;p&gt; Note that this function should not be used with the Connection header, i.e. setHeader("Connection", value) since it may not give the expected results. &lt;/p&gt;&lt;p&gt; The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.addHeader" />
                  <related func="http.getHeader" />
                  <related func="http.headerExists" />
                  <related func="http.removeHeader" />
                  <related func="http.setResponseHeader" />
               </relatedFunctions>
            </func>
            <func name="http.setIdempotent">
               <parameters min="1" max="1" regex=".">
                  <param name="resend" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.setIdempotent() marks a request as resendable or non-resendable. &lt;/p&gt;&lt;p&gt; An &lt;i&gt;idempotent&lt;/i&gt; request has no detrimental side effects, so it can safely be submitted multiple times. A simple page retrieval is generally idempotent. A non-idempotent request has a side effect - for example, it may update a database, or initiate a purchase. The HTTP/1.1 specification regards all GET, HEAD, PUT, DELETE, OPTIONS and TRACE requests as idempotent. &lt;/p&gt;&lt;p&gt; ZXTM tags these requests as 'resendable'; if the request is submitted to a back-end node and a correct response is not received, ZXTM will resubmit the request to another back-end node. All other requests, such as POST requests are not resent if a back-end node fails to generate a correct response. &lt;/p&gt;&lt;p&gt; http.setIdempotent() can override this behaviour. If 'resend' has a non-zero value, this indicates that if the request is submitted to a back-end node and a correct response is not received, ZXTM should resubmit the request to another back-end node. &lt;/p&gt;&lt;p&gt; If 'resend' is zero, this indicates that the request should only be attempted against one back-end node. &lt;/p&gt;&lt;p&gt; Note that ZXTM cannot resend a request if it has begun streaming data from the client to the node before it detects the failure. To avoid this, you can read the entire request within the TrafficScript rule, so that it is buffered in its entirety internally in the TrafficManager. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.setIdempotent" />
               </relatedFunctions>
            </func>
            <func name="http.setMethod">
               <parameters min="1" max="1" regex=".">
                  <param name="method" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.setMethod() sets the HTTP method to use when forwarding the request via a pool to a node. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getMethod" />
               </relatedFunctions>
            </func>
            <func name="http.setPath">
               <parameters min="1" max="1" regex=".">
                  <param name="url" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.setPath() replaces the Path portion of the request URL with the supplied value. If the replacement value contains a '?', this function will also replace the query string; otherwise, any query string is preserved. Any control characters are %-encoded in the replacement value. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getPath" />
               </relatedFunctions>
            </func>
            <func name="http.setQueryString">
               <parameters min="1" max="1" regex=".">
                  <param name="querystring" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.setQueryString() replaces the query-string portion of the request URL with the supplied replacement. Any control characters in the replacement are %-encoded. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getQueryString" />
                  <related func="http.setRawQueryString" />
                  <related func="http.getRawQueryString" />
               </relatedFunctions>
            </func>
            <func name="http.setRawQueryString">
               <parameters min="1" max="1" regex=".">
                  <param name="querystring" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.setRawQueryString() replaces the query-string portion of the request URL with the supplied replacement. Unlike http.setQueryString control characters are not encoded. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getRawQueryString" />
                  <related func="http.setQueryString" />
                  <related func="http.getQueryString" />
               </relatedFunctions>
            </func>
            <func name="http.setResponseBody">
               <parameters min="1" max="2" regex="..?">
                  <param name="body" />
                  <param name="transfer-encoding" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.setResponseBody() sets the response body for this HTTP response to the supplied string, replacing any response body already present. &lt;/p&gt;&lt;p&gt; This also updates the 'Content-Length' header in the response to the length of the new body data. In addition the 'Content-Encoding' header is removed as we only ever set body data which is not encoded or compressed. If the server is still sending the original response body when this function is called, the connection to the server will be harmlessly dropped. &lt;/p&gt;&lt;p&gt; The optional transfer-encoding parameter indicates the encoding of the body data (for example, 'chunked'). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseBody" />
                  <related func="http.setBody" />
               </relatedFunctions>
            </func>
            <func name="http.setResponseCode">
               <parameters min="1" max="2" regex=".|..">
                  <param name="code" />
                  <param name="message" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.setResponseCode() sets the status code and message in the first line of the HTTP response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseCode" />
               </relatedFunctions>
            </func>
            <func name="http.setResponseCookie">
               <parameters min="2" max="3" regex="..|...">
                  <param name="name" />
                  <param name="value" />
                  <param name="options" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.setResponseCookie() sets the value of the named cookie in the HTTP response. &lt;/p&gt;&lt;p&gt; http.setResponseCookie is a helper method to make it easier to parse the HTTP Set-Cookie header and set the value of a particular cookie, rather than using http.getResponseHeader() and http.setResponseHeader() directly. &lt;/p&gt;&lt;p&gt; The options are a semi-colon separated list of cookie options, such as 'domain', 'path', 'exipres' and 'secure'. These options are defined in the Netscape Cookie specification, at http://wp.netscape.com/newsref/std/cookie_spec.html &lt;/p&gt;&lt;p&gt; If the named cookie already exists, this function replaces its value. &lt;/p&gt;&lt;p&gt; If the named cookie exists and no 'options' are provided, the current options for the named cookie are preserved. &lt;/p&gt;&lt;p&gt; This function may be called from a request rule or a response rule. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.getResponseCookie" />
                  <related func="http.removeResponseCookie" />
                  <related func="http.setCookie" />
               </relatedFunctions>
            </func>
            <func name="http.setResponseHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; http.setResponseHeader() sets a HTTP header in the HTTP response that will be sent back to the client. If the header already exists in the response, then it will be replaced with this new value. &lt;/p&gt;&lt;p&gt; Note that this function should not be used with the Connection header, i.e. setResponseHeader("Connection", value) since it may not give the expected results. &lt;/p&gt;&lt;p&gt; The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.addResponseHeader" />
                  <related func="http.getResponseHeader" />
                  <related func="http.removeResponseHeader" />
                  <related func="http.setHeader" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="http.cache">
         <description>Functions affecting the HTTP cache.</description>
         <functions>
            <func name="http.cache.disable">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; Invoking http.cache.disable() in a response rule prevents the response from being cached. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.cache.enable" />
                  <related func="http.cache.setkey" />
               </relatedFunctions>
            </func>
            <func name="http.cache.enable">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.cache.enable() performs the opposite function to http.cache.disable(), and re-enables the default caching behaviour when the dynamic caching option in the virtual server is enabled. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.cache.disable" />
                  <related func="http.cache.setkey" />
               </relatedFunctions>
            </func>
            <func name="http.cache.setkey">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.cache.setkey() allows multiple variants of the same URL to be considered distinct objects, even if the standard 'Vary' RFC semantics would consider the pages identical. Cached objects will be stored with this key, and subsequent requests for the same URL will only match if the same key is provided. An example use is to provided different cached content based on a portion of the User-Agent field of the request. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.cache.enable" />
                  <related func="http.cache.disable" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="http.compress">
         <description>Functions affecting the HTTP compression of this connection.</description>
         <functions>
            <func name="http.compress.disable">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.compress.disable() stops an HTTP response from being compressed. This function overrides the Virtual Server Content Compression settings, so this is useful for stopping particular MIME types for certain browsers from being compressed. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.compress.enable" />
               </relatedFunctions>
            </func>
            <func name="http.compress.enable">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_HTTP" />
               </restrictions>
               <description>&lt;p&gt; http.compress.enable() allows an individual HTTP response to be compressed. If this function is called for an HTTP response, then the Virtual Server settings for Content Compression are ignored, and the response will be compressed assuming that the client supports compression. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.compress.disable" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="http.request">
         <description>Functions that allow you to send HTTP requests within TrafficScript rules.</description>
         <functions>
            <func name="http.request.get">
               <parameters min="1" max="3" regex=".|..|...">
                  <param name="url" />
                  <param name="headers" />
                  <param name="timeout" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; http.request.get() issues an HTTP request for a remote web page and returns the body of the page requested. $1 is set to the HTTP response code (e.g. 200 for OK), or is 0 if there was an error. $2 is set to the Content-Type of the response. $3 is set to the content-headers of the response, in the format: [&lt;header-line&gt;\r\n]*. $4 is set to the first line of the HTTP response. The entire original response may be reconstructed as $4."\r\n".$3."\r\n".$body, where $body is the result of http.request.get. &lt;/p&gt;&lt;p&gt; HTTPS pages can be requested by using the https:// prefix for the url. &lt;/p&gt;&lt;p&gt; A timeout parameter can be given (in seconds). If the request does not complete in this time, then an error will be given instead. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.request.head" />
                  <related func="http.request.post" />
               </relatedFunctions>
            </func>
            <func name="http.request.head">
               <parameters min="1" max="3" regex=".|..|...">
                  <param name="url" />
                  <param name="headers" />
                  <param name="timeout" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; http.request.head() issues an HTTP HEAD request for a remote web page. $1 is set to the HTTP response code (e.g. 200 for OK), or is 0 if there was an error. $2 is set to the Content-Type of the response. $3 is set to the content-headers of the response, in the format: [&lt;header-line&gt;\r\n]*. $4 is set to the first line of the HTTP response. The entire original response may be reconstructed as $4."\r\n".$3."\r\n".$body, where $body is the result of http.request.get. &lt;/p&gt;&lt;p&gt; HTTPS pages can be requested by using the https:// prefix for the url. &lt;/p&gt;&lt;p&gt; A timeout parameter can be given (in seconds). If the request does not complete in this time, then an error will be given instead. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.request.post" />
               </relatedFunctions>
            </func>
            <func name="http.request.post">
               <parameters min="2" max="4" regex="..|...|....">
                  <param name="url" />
                  <param name="POST data" />
                  <param name="headers" />
                  <param name="timeout" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; http.request.post() issues an HTTP POST request for a remote web page, and returns the body of the page requested. $1 is set to the HTTP response code (e.g. 200 for OK), or is 0 if there was an error. $2 is set to the Content-Type of the response. $3 is set to the content-headers of the response, in the format: [&lt;header-line&gt;\r\n]*. $4 is set to the first line of the HTTP response. The entire original response may be reconstructed as $4."\r\n".$3."\r\n".$body, where $body is the result of http.request.post. &lt;/p&gt;&lt;p&gt; HTTPS pages can be requested by using the https:// prefix for the url. &lt;/p&gt;&lt;p&gt; A timeout parameter can be given (in seconds). If the request does not complete in this time, then an error will be given instead. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.request.get" />
                  <related func="http.request.head" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="java">
         <description>Functions relating to Java Extensions.</description>
         <functions>
            <func name="java.run">
               <parameters min="1" max="INF" regex=".+">
                  <param name="Java Extension class name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
                  <restriction type="ZXTM_JAVA" />
               </restrictions>
               <description>&lt;p&gt; java.run runs a named Java Extension. The Java Extension class name must be given, and extra options can also be supplied to the Extensions. (These are supplied as the 'args' attribute in the Java Extension API). &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="lang">
         <description>Standard functions, mostly for converting data types.</description>
         <functions>
            <func name="lang.chr">
               <parameters min="1" max="1" regex=".">
                  <param name="number" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; lang.chr() converts its parameter to the corresponding ASCII character. chr() may be used an a shorthand alias for lang.chr(). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.ord" />
               </relatedFunctions>
            </func>
            <func name="lang.max">
               <parameters min="2" max="2" regex="..">
                  <param name="param1" />
                  <param name="param2" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; lang.max() returns the maximum value of the two parameters provided. If both parameters are strings, it uses a string comparison; otherwise, the parameters are promoted to integers or doubles and compared. max() may be used as a shorthand for lang.max(). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.min" />
               </relatedFunctions>
            </func>
            <func name="lang.min">
               <parameters min="2" max="2" regex="..">
                  <param name="param1" />
                  <param name="param2" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; lang.min() returns the minimum value of the two parameters provided. If both parameters are strings, it uses a string comparison; otherwise, the parameters are promoted to integers or doubles and compared. min() may be used as a shorthand for lang.min(). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.max" />
               </relatedFunctions>
            </func>
            <func name="lang.ord">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; lang.ord() converts its parameter, an ascii character, to an integer. ord() may be used as a shorthand alias for lang.ord(). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.toString" />
                  <related func="lang.chr" />
               </relatedFunctions>
            </func>
            <func name="lang.toDouble">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; lang.toDouble() returns the double (floating point) value of its parameter, using the TrafficScript type-casting rules. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.toInt" />
                  <related func="lang.toString" />
               </relatedFunctions>
            </func>
            <func name="lang.toInt">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; lang.toInt() returns the integer value of its parameter, using the TrafficScript type-casting rules. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.toDouble" />
                  <related func="lang.toString" />
               </relatedFunctions>
            </func>
            <func name="lang.toString">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; lang.toString() returns the string value of its parameter, using the TrafficScript type-casting rules. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.toInt" />
                  <related func="lang.toDouble" />
                  <related func="lang.chr" />
                  <related func="lang.ord" />
               </relatedFunctions>
            </func>
            <func name="lang.tochar">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; This function is an alias for lang.chr. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="lang.chr" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="log">
         <description>Functions for writing to the event log.</description>
         <functions>
            <func name="log.error">
               <parameters min="1" max="1" regex=".">
                  <param name="message" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; log.error() writes an error message to ZXTM's log file at &lt;i&gt;ZEUSHOME&lt;/i&gt;/zxtm/log/errors: &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;[21/Jan/2004:10:42:50 +0000] SERIOUS:Insert coffee to continue &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="log.info" />
                  <related func="log.warn" />
                  <related func="event.emit" />
               </relatedFunctions>
            </func>
            <func name="log.info">
               <parameters min="1" max="1" regex=".">
                  <param name="message" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; log.info() writes an informational message to ZXTM's log file at &lt;i&gt;ZEUSHOME&lt;/i&gt;/zxtm/log/errors: &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;[21/Jan/2004:10:42:50 +0000] INFO:Everything is OK &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="log.warn" />
                  <related func="log.error" />
                  <related func="event.emit" />
               </relatedFunctions>
            </func>
            <func name="log.warn">
               <parameters min="1" max="1" regex=".">
                  <param name="message" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; log.warn() writes a warning message to ZXTM's log file at &lt;i&gt;ZEUSHOME&lt;/i&gt;/zxtm/log/errors: &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;[21/Jan/2004:10:42:52 +0000] WARN:There may be trouble ahead &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="log.info" />
                  <related func="log.error" />
                  <related func="event.emit" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="math">
         <description>Mathematical functions for manipulating numbers.</description>
         <functions>
            <func name="math.acos">
               <parameters min="1" max="1" regex=".">
                  <param name="x" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.acos() calculates the arc cosine of x and returns an angle in radians in the range 0 to pi. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.cos" />
               </relatedFunctions>
            </func>
            <func name="math.asin">
               <parameters min="1" max="1" regex=".">
                  <param name="x" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.asin() calculates the arc sine of x and returns an angle in radians in the range -pi/2 to pi/2. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.sin" />
               </relatedFunctions>
            </func>
            <func name="math.atan">
               <parameters min="1" max="1" regex=".">
                  <param name="angle" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.atan() calculates the arc tangent of x and returns an angle in radians in the range -pi/2 to pi/2. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.tan" />
               </relatedFunctions>
            </func>
            <func name="math.ceil">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.ceil() returns the smallest integer greater than or equal to its parameter. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.floor" />
                  <related func="math.rint" />
                  <related func="math.fabs" />
               </relatedFunctions>
            </func>
            <func name="math.cos">
               <parameters min="1" max="1" regex=".">
                  <param name="angle" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.cos() interprets its parameter as an angle in radians and returns its cosine. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.sin" />
                  <related func="math.tan" />
               </relatedFunctions>
            </func>
            <func name="math.exp">
               <parameters min="1" max="1" regex=".">
                  <param name="power" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.exp() calculates e raised to the power of its parameter and returns the result. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.ln" />
                  <related func="math.pow" />
               </relatedFunctions>
            </func>
            <func name="math.fabs">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.fabs() interprets its parameter as a floating point number and returns its absolute value. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.floor" />
                  <related func="math.ceil" />
                  <related func="math.rint" />
               </relatedFunctions>
            </func>
            <func name="math.floor">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.floor() returns the largest integer not greater than its parameter. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.ceil" />
                  <related func="math.rint" />
                  <related func="math.fabs" />
               </relatedFunctions>
            </func>
            <func name="math.ln">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.ln() returns the natural logarithm of its parameter. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.log" />
                  <related func="math.exp" />
               </relatedFunctions>
            </func>
            <func name="math.log">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.log() returns the base10 logarithm of its parameter. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.ln" />
                  <related func="math.pow" />
               </relatedFunctions>
            </func>
            <func name="math.pow">
               <parameters min="2" max="2" regex="..">
                  <param name="num" />
                  <param name="power" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.pow() raises its first parameter to the power of its second parameter and returns the result. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.ln" />
                  <related func="math.exp" />
                  <related func="math.sqrt" />
               </relatedFunctions>
            </func>
            <func name="math.random">
               <parameters min="1" max="1" regex=".">
                  <param name="range" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.random() returns a pseudorandom integer greater than or equal to zero, and less than its parameter. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="math.rint">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.rint() rounds its parameter by returning the integer closest to its value. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.floor" />
                  <related func="math.ceil" />
                  <related func="math.fabs" />
               </relatedFunctions>
            </func>
            <func name="math.sin">
               <parameters min="1" max="1" regex=".">
                  <param name="angle" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.sin() interprets its parameter as an angle in radians and returns its sine. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.cos" />
                  <related func="math.tan" />
               </relatedFunctions>
            </func>
            <func name="math.sqrt">
               <parameters min="1" max="1" regex=".">
                  <param name="num" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.sqrt() returns the square root of its parameter. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.pow" />
               </relatedFunctions>
            </func>
            <func name="math.tan">
               <parameters min="1" max="1" regex=".">
                  <param name="angle" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; math.tan() interprets its parameter as an angle in radians and returns its tangent. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="math.sin" />
                  <related func="math.cos" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="net.dns">
         <description>DNS lookup functions.</description>
         <functions>
            <func name="net.dns.resolveHost">
               <parameters min="1" max="1" regex=".">
                  <param name="hostname" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; net.dns.resolveHost() resolves a hostname into an IPv4 address, using the DNS name servers configured on the local system. If the lookup fails, an empty string is returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="net.dns.resolveIP" />
                  <related func="net.dns.resolveHost6" />
               </relatedFunctions>
            </func>
            <func name="net.dns.resolveHost6">
               <parameters min="1" max="1" regex=".">
                  <param name="hostname" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; net.dns.resolveHost6() resolves a hostname into an IPv6 address, using the DNS name servers configured on the local system. If the lookup fails, an empty string is returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="net.dns.resolveHost" />
                  <related func="net.dns.resolveIP" />
               </relatedFunctions>
            </func>
            <func name="net.dns.resolveIP">
               <parameters min="1" max="1" regex=".">
                  <param name="IP address" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; net.dns.resolveIP() resolves an IP address to a hostname, using the DNS name servers configured on the local system. &lt;/p&gt;&lt;p&gt; It returns a hostname, or the IP address if the address cannot be resolved. An empty string is returned if the parameter is not a valid IP address. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="net.dns.resolveHost" />
                  <related func="net.dns.resolveHost6" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="pool">
         <description> Functions that allow you to look up and alter which pool the current request will be assigned to.</description>
         <functions>
            <func name="pool.activenodes">
               <parameters min="1" max="1" regex=".">
                  <param name="Pool" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; pool.activeNodes() returns the number of nodes that are alive in the named pool. This will not include any nodes that have been marked as 'draining'. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="pool.use" />
                  <related func="pool.select" />
               </relatedFunctions>
            </func>
            <func name="pool.select">
               <parameters min="1" max="3" regex=".|...">
                  <param name="Pool" />
                  <param name="Host" />
                  <param name="Port" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; pool.select() selects a pool to load-balance this connection with. By default the pool name should be a literal string, however, if you enable the "trafficscript!variable_pool_use" global setting variables can be used too. Please refer to section 5.5 of the ZXTM TrafficScript Overview and Reference for more information about this setting. ZXTM will continue to process any request rules. &lt;/p&gt;&lt;p&gt; If the pool named does not exist, ZXTM will log a warning message. &lt;/p&gt;&lt;p&gt; Optionally, a specific machine can be specified that will be used to forward the request on to. This machine does not have to be in the pool selected, or in fact in any pool. In this mode, the selected pool is used only for its configuration settings (e.g. timeout values, SSL encryption options, etc.) &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="pool.use" />
               </relatedFunctions>
            </func>
            <func name="pool.use">
               <parameters min="1" max="3" regex=".|...">
                  <param name="Pool" />
                  <param name="Host" />
                  <param name="Port" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; pool.use() selects a pool to load-balance this connection with, and stops processing any more rules. It must only be used in request rules. &lt;/p&gt;&lt;p&gt; By default the pool name should be a literal string, however, if you enable the "trafficscript!variable_pool_use" global setting, variables can be used too. Please refer to section 5.5 of the ZXTM TrafficScript Overview and Reference for more information about this setting. &lt;/p&gt;&lt;p&gt; If the pool named does not exist, ZXTM will log a warning message and use the default pool configured for the virtual server. &lt;/p&gt;&lt;p&gt; Optionally, a specific machine can be specified that will be used to forward the request on to. This machine does not have to be in the pool selected, or in fact in any pool. In this mode, the selected pool is used only for its configuration settings (e.g. timeout values, SSL encryption options, etc.) &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="pool.select" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="rate">
         <description>Functions that allow you to monitor and assign rate shaping classes.</description>
         <functions>
            <func name="rate.getbacklog">
               <parameters min="1" max="2" regex=".|..">
                  <param name="class_name" />
                  <param name="context" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; rate.getBacklog return the number of connections that are currently waiting to be released by the supplied rate class. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rate.use" />
               </relatedFunctions>
            </func>
            <func name="rate.use">
               <parameters min="1" max="2" regex=".|..">
                  <param name="class_name" />
                  <param name="context" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; rate.use immediately queues a connection using the named rate class. The connection and the current TrafficScript rule is stalled until the rate class releases it, according to the rate limits defined in the class. When the connection is released, the rate.use() function returns and the TrafficScript rule continues to execute. If rate.use is called with the optional 'context' value, it uses a new rate class which inherits all of the rate settings from the named rate class. All connections called with the same 'context' value use the same new rate class. This allows you to shape connections based on arbitary data, such as a user name or source IP address, shaping connections from different users or source IPs independently. If the connection has passed through the class successfully then the value 1 is returned. If the connection times out while it is queued, then the TrafficScript rule is abandoned. If the connection could not be queued because an invalid rate class name was provided, rate.use() returns 0. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="request">
         <description>Functions that allow you to access information about and modify the current request.</description>
         <functions>
            <func name="request.avoidNode">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.avoidNode() can be used to indicate that ZXTM should avoid using the named node if at all possible, if it retries the request. &lt;/p&gt;&lt;p&gt; When retrying a request, ZXTM will not use any nodes that have been named by request.avoidNode() unless session persistence mandates it, or unless there are no other nodes available. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.retry" />
                  <related func="request.getRetries" />
                  <related func="connection.getNode" />
               </relatedFunctions>
            </func>
            <func name="request.endsAt">
               <parameters min="1" max="1" regex=".">
                  <param name="offset" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.endsAt() marks the end of the current request. Any more data read in from the network is not handled until ZXTM begins to handle the next request. &lt;/p&gt;&lt;p&gt; This function is useful to synchronise requests and responses. An example of its use would be for a line-oriented protocol such as POP3, where you wish to process each command. &lt;/p&gt;&lt;p&gt; It returns the entire request. &lt;/p&gt;&lt;p&gt; This function allows you to program layer-7 intelligence to correctly parse and manage generic TCP protocols. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.endsWith" />
               </relatedFunctions>
            </func>
            <func name="request.endsWith">
               <parameters min="1" max="1" regex=".">
                  <param name="regex" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.endsWith() marks the end of the current request. Any more data read in from the network is not handled until ZXTM begins to handle the next request. &lt;/p&gt;&lt;p&gt; This function is useful to synchronise requests and responses. An example of its use would be for a line-oriented protocol such as POP3, where you wish to process each command. &lt;/p&gt;&lt;p&gt; It returns the entire request. &lt;/p&gt;&lt;p&gt; This function allows you to program layer-7 intelligence to correctly parse and manage generic TCP protocols. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.endsAt" />
               </relatedFunctions>
            </func>
            <func name="request.get">
               <parameters min="0" max="1" regex=".?">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.get() returns the first 'count' bytes of data provided by the client in the current request. If no count parameter is provided, then ZXTM immediately returns all available data. &lt;/p&gt;&lt;p&gt; Warning: you can stall a connection by asking it to read more data than the remote client will provide. Combine this with request.getLength() or request.getLine() to reliably read data from a connection. For HTTP, you are advised to use the HTTP specific functions like http.getBody() to read the request. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getLength" />
                  <related func="request.getLine" />
                  <related func="request.set" />
                  <related func="response.get" />
               </relatedFunctions>
            </func>
            <func name="request.getBandwidthClass">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_BW" />
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; request.getBandwidthClass() gets the current bandwidth class for the connection to the backend node. It will return an empty string if no class is set. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.setBandwidthClass" />
                  <related func="response.setBandwidthClass" />
                  <related func="response.getBandwidthClass" />
               </relatedFunctions>
            </func>
            <func name="request.getDestIP">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; request.getDestIP returns the original IP address that the client attempted to connect to. This will be the same as request.getLocalIP() unless the connection was redirected via firewall rules (e.g. using iptables on Linux) &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getDestPort" />
                  <related func="request.getRemoteIP" />
                  <related func="request.getRemotePort" />
               </relatedFunctions>
            </func>
            <func name="request.getDestPort">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.getDestIP returns the original network port number that the client attempted to connect to. This will be the same as request.getLocalPort() unless the connection was redirected via firewall rules (e.g. using iptables on Linux) &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getDestIP" />
                  <related func="request.getRemotePort" />
                  <related func="request.getRemoteIP" />
               </relatedFunctions>
            </func>
            <func name="request.getLength">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.getLength() returns the amount of data already received from the client. This can be combined with request.get() to reliably read data from a connection without stalling if no data is available. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.get" />
                  <related func="response.getLength" />
               </relatedFunctions>
            </func>
            <func name="request.getLine">
               <parameters min="0" max="2" regex=".?.?">
                  <param name="regex" />
                  <param name="offset" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.getLine() returns a line of request data provided by the client. The line is terminated by the supplied regular expression, or by '\n'. If 'offset' is provided, request.getLine() returns the data from that offset to the terminating expression. The terminating expression is included in the returned string. &lt;/p&gt;&lt;p&gt; When request.getline() returns, the variable $1 is updated to point to the start of the next line in the datastream. &lt;/p&gt;&lt;p&gt; You can iterate through the lines of request data by using $1 as the iterator variable. &lt;/p&gt;&lt;p&gt; To prevent excessive data usage, if the line ending is not found within trafficscript!memory_warning bytes (configurable on the Global Settings page), then that many bytes will be returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.get" />
                  <related func="response.getLine" />
               </relatedFunctions>
            </func>
            <func name="request.getLocalIP">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; request.getLocalIP returns the IP address that the client connected to, i.e. the address local to this machine. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getLocalPort" />
                  <related func="request.getDestIP" />
                  <related func="request.getRemoteIP" />
                  <related func="request.getRemotePort" />
                  <related func="response.getLocalIP" />
                  <related func="response.getLocalPort" />
                  <related func="response.getRemoteIP" />
                  <related func="response.getRemotePort" />
               </relatedFunctions>
            </func>
            <func name="request.getLocalPort">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.getLocalPort returns the network port number that the client connected to. (e.g. port 80 is normal for a web server) &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getLocalIP" />
                  <related func="request.getRemotePort" />
                  <related func="request.getDestPort" />
                  <related func="request.getRemoteIP" />
                  <related func="response.getLocalPort" />
                  <related func="response.getLocalIP" />
                  <related func="response.getRemotePort" />
                  <related func="response.getRemoteIP" />
               </relatedFunctions>
            </func>
            <func name="request.getRemoteIP">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; request.getRemoteIP returns the remote IP address of the client. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getRemotePort" />
                  <related func="request.getLocalIP" />
                  <related func="request.setRemoteIP" />
                  <related func="request.getLocalPort" />
                  <related func="response.getRemoteIP" />
                  <related func="response.getRemotePort" />
                  <related func="response.getLocalIP" />
                  <related func="response.getLocalPort" />
               </relatedFunctions>
            </func>
            <func name="request.getRemotePort">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; request.getRemotePort returns the remote network port of the client's connection. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getRemoteIP" />
                  <related func="request.getLocalPort" />
                  <related func="request.getLocalIP" />
                  <related func="response.getRemotePort" />
                  <related func="response.getRemoteIP" />
                  <related func="response.getLocalPort" />
                  <related func="response.getLocalIP" />
               </relatedFunctions>
            </func>
            <func name="request.getRetries">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.getRetries() returns the number of times that this request has been explicitly retried by request.retry(). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.retry" />
                  <related func="request.isResendable" />
                  <related func="pool.select" />
               </relatedFunctions>
            </func>
            <func name="request.getToS">
               <parameters min="0" max="0" regex="">
                  <param name="Type of Service" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.getToS returns the Type of Service (ToS) of traffic going to the server. The return value is either "LOWDELAY", "THROUGHPUT", "RELIABILITY" or "NONE". &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getToS" />
                  <related func="request.setToS" />
               </relatedFunctions>
            </func>
            <func name="request.getfd">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.getfd() returns the number of the file descriptor used for communication with the client. It returns -1 on failure. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getfd" />
               </relatedFunctions>
            </func>
            <func name="request.isResendable">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.isResendable() is used in a response rule to test if it is possible to resend a request to a different node. It is only possible to resend a request if the entire request has been buffered up in ZXTM, for example, by explicitly reading it in a request rule. &lt;/p&gt;&lt;p&gt; If the request was streamed through to the client, for example, as a large HTTP POST, it will not have been buffered and therefore cannot be resent. &lt;/p&gt;&lt;p&gt; Note that request.isResendable detects if it is possible to resend a request; request.setIdempotent can be used to tell ZXTM not to automatically resend a request if it fails. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.retry" />
                  <related func="request.getRetries" />
                  <related func="request.setIdempotent" />
               </relatedFunctions>
            </func>
            <func name="request.retry">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.retry() is used in a response rule to retry the request against the selected pool. Load-balancing and session persistence decisions are recalculated, and the request is resubmitted - possibly to the same node as previous, although request.avoidNode() can prevent this. &lt;/p&gt;&lt;p&gt; If request.retry() is called, any request rules are not run again. When a new response is collected after request.retry(), the response rules are run again. &lt;/p&gt;&lt;p&gt; The response rule can modify the request in before resubmitting it. &lt;/p&gt;&lt;p&gt; It's only generally possible to resend a request if the entire request was read before the request rules completed. Otherwise, request data will have been streamed to the server and not cached. Use request.isResendable() to test this speculatively. &lt;/p&gt;&lt;p&gt; request.getRetries() returns the number of times this request has been tried already. &lt;/p&gt;&lt;p&gt; On success, request.retry() does not return, but the response rules will be run again on the new response. On failure, request.retry() returns 0. request.retry() will do nothing if used in a request rule. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.isResendable" />
                  <related func="request.getRetries" />
                  <related func="pool.select" />
               </relatedFunctions>
            </func>
            <func name="request.sendResponse">
               <parameters min="1" max="1" regex=".">
                  <param name="Data" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.sendResponse() writes the provided data directly back to the client. &lt;/p&gt;&lt;p&gt; Any data that has been read is discarded, and nothing is forwarded to the back-end node. Once the response data has been written, control returns to the next request. &lt;/p&gt;&lt;p&gt; If you are managing HTTP traffic the http.sendResponse() function should be used instead. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.discard" />
                  <related func="http.sendResponse" />
                  <related func="response.set" />
                  <related func="response.append" />
                  <related func="connection.close" />
               </relatedFunctions>
            </func>
            <func name="request.set">
               <parameters min="1" max="1" regex=".">
                  <param name="request data" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.set() replaces the input data read from the client with the provided string. &lt;/p&gt;&lt;p&gt; This is a low-level routine that should be used with care. For protocols with their own higher-level protocol managers (e.g. http), use the higher level routines to alter the input data (e.g. http.setHeader() and http.setBody()). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.get" />
                  <related func="response.set" />
               </relatedFunctions>
            </func>
            <func name="request.setBandwidthClass">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_BW" />
                  <restriction type="ZXTM_TCP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; request.setBandwidthClass() sets the bandwidth class for the current connection to the backend node. Providing an empty class name removes the bandwidth class from the connection. It returns zero if an error occurs (for example, if the bandwidth class does not exist), and 1 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getBandwidthClass" />
                  <related func="response.setBandwidthClass" />
                  <related func="response.getBandwidthClass" />
               </relatedFunctions>
            </func>
            <func name="request.setIdempotent">
               <parameters min="1" max="1" regex=".">
                  <param name="resend" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.setIdempotent() marks a request as resendable or non-resendable. &lt;/p&gt;&lt;p&gt; An &lt;i&gt;idempotent&lt;/i&gt; request has no detrimental side effects, so it can safely be attempted multiple times. A non-idempotent request has a side effect - for example, it may update a database, or initiate a purchase. &lt;/p&gt;&lt;p&gt; By default, all non-HTTP requests are marked as idempotent. If a back-end node fails to generate a correct response when a request is initially forwarded to it, ZXTM will attempt to resend the request to another node. &lt;/p&gt;&lt;p&gt; request.setIdempotent() can override this behaviour. If 'resend' is zero, this indicates that the request should only be attempted against one back-end node. &lt;/p&gt;&lt;p&gt; If 'resend' has a non-zero value, this indicates that if a request is made to a back-end node and a correct response is not received, ZXTM should retry the request against another back-end node. &lt;/p&gt;&lt;p&gt; Note that ZXTM cannot resend a request once it has begun streaming data between the client and the node. Additionally, UDP connections cannot be marked as resendable (the UDP client application should handle failed UDP responses). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="http.setIdempotent" />
               </relatedFunctions>
            </func>
            <func name="request.setRemoteIP">
               <parameters min="1" max="1" regex=".">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.setRemoteIP sets the remote IP address of the client. This function should be used with care, as it will alter what is logged in request logs and the address seen by a back-end node in 'transparent' mode. 0 is returned if the IP address is invalid, and 1 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getRemoteIP" />
               </relatedFunctions>
            </func>
            <func name="request.setToS">
               <parameters min="1" max="1" regex=".">
                  <param name="Type of Service" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.setToS sets the Type of Service (ToS) of traffic going to the server to either "LOWDELAY", "THROUGHPUT", "RELIABILITY" or "NONE". &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.setToS" />
                  <related func="request.getToS" />
               </relatedFunctions>
            </func>
            <func name="request.skip">
               <parameters min="1" max="1" regex=".">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; request.skip() removes the specified number of bytes from the start of the request provided by the client. This can be used in combination with request.get() and request.getLine() to stream data from a client, or to alter a request before passing it on to a server. &lt;/p&gt;&lt;p&gt; Successive calls to this function will remove further data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getLength" />
                  <related func="request.getLine" />
                  <related func="request.set" />
                  <related func="request.get" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="resource">
         <description>Functions that allow you to access files uploaded to the 'Extra Files' section of the traffic manager.</description>
         <functions>
            <func name="resource.exists">
               <parameters min="1" max="1" regex=".">
                  <param name="filename" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; resource.exists() checks whether or not the named file exists in &lt;i&gt;ZEUSHOME&lt;/i&gt;/zxtm/conf/extra/. If it exists 1 is returned, 0 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="resource.get" />
                  <related func="resource.getMD5" />
               </relatedFunctions>
            </func>
            <func name="resource.get">
               <parameters min="1" max="1" regex=".">
                  <param name="filename" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; resource.get() returns the contents of a named file stored in the &lt;i&gt;ZEUSHOME&lt;/i&gt;/zxtm/conf/extra/ directory. If the file doesn't exist, then an empty string is returned. Note that subdirectories of conf/extra are not supported. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="resource.getMD5">
               <parameters min="1" max="1" regex=".">
                  <param name="filename" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; resource.getMD5() returns the MD5 of the current contents of the file in &lt;i&gt;ZEUSHOME&lt;/i&gt;/zxtm/conf/extra/. If the file doesn't exist, an empty string is returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="resource.exists" />
                  <related func="resource.get" />
               </relatedFunctions>
            </func>
            <func name="resource.getMTime">
               <parameters min="1" max="1" regex=".">
                  <param name="filename" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; resource.getMTime() returns the last time that the named file in &lt;i&gt;ZEUSHOME&lt;/i&gt;/zxtm/conf/extra/ was modified, in seconds since the epoch (i.e. UNIX time). If the file doesn't exist, 0 is returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="resource.exists" />
                  <related func="resource.get" />
                  <related func="resource.getMD5" />
                  <related func="sys.timeToString" />
                  <related func="sys.time" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="response">
         <description>Functions that allow you to access information about and modify the current response.</description>
         <functions>
            <func name="response.append">
               <parameters min="1" max="1" regex=".">
                  <param name="response data" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.append() appends the provided string to the response data &lt;/p&gt;&lt;p&gt; This is a low-level routine that should be used with care. For protocols with their own higher-level protocol managers (e.g. http), use the higher level routines to alter the input data (e.g. http.setHeader() and http.setBody()). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.set" />
               </relatedFunctions>
            </func>
            <func name="response.close">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; response.close() immediately closes the connection to the back-end node. Any response data that has already been read from the server will be forwarded to the client, but no more response data will be read. &lt;/p&gt;&lt;p&gt; ZXTM will reconnect to a back-end node when it next needs to forward request data to it; the back-end node is specified by either calling pool.use() or pool.select() in a request rule, or by the default pool. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="connection.close" />
                  <related func="connection.discard" />
                  <related func="pool.use" />
                  <related func="pool.select" />
               </relatedFunctions>
            </func>
            <func name="response.flush">
               <parameters min="0" max="1" regex=".?">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; response.flush() transfers the first count bytes of the response back to the client. These bytes are removed from the underlying response buffer. If count is not specified, all current response data is flushed. &lt;/p&gt;&lt;p&gt; This function is useful in generic client- and server-first protocols, to synchronise responses with the next request. This may be necessary if ZXTM is likely to respond directly to some requests, and the back-end node responds to others. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.get" />
                  <related func="response.getLine" />
               </relatedFunctions>
            </func>
            <func name="response.get">
               <parameters min="0" max="1" regex=".?">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; response.get() returns the first 'count' bytes of data provided by the server in the current response. If you do not supply a count parameter, then the entire response will be read in. &lt;/p&gt;&lt;p&gt; Warning: you can stall a connection by asking it to read more data than the back-end server will provide. Combine this with response.getLength() or response.getLine() to reliably read data from a connection. For HTTP, you are advised to use the HTTP specific functions like http.getResponseBody() to read the response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getLength" />
                  <related func="response.getLine" />
                  <related func="response.set" />
                  <related func="request.get" />
               </relatedFunctions>
            </func>
            <func name="response.getBandwidthClass">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_BW" />
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; response.getBandwidthClass() gets the current bandwidth class for the connection to the client. It will return an empty string if no class is set. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.setBandwidthClass" />
                  <related func="request.setBandwidthClass" />
                  <related func="request.getBandwidthClass" />
               </relatedFunctions>
            </func>
            <func name="response.getLength">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.getLength() returns the amount of data already received from the server. This can be combined with response.get() to reliably read data from a connection without stalling if no data is available. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.get" />
                  <related func="request.getLength" />
               </relatedFunctions>
            </func>
            <func name="response.getLine">
               <parameters min="0" max="2" regex=".?.?">
                  <param name="regex" />
                  <param name="offset" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; response.getLine() returns a line of response data provided by the server. The line is terminated by the supplied regular expression, or by '\n'. If 'offset' is provided, response.getLine() returns the data from that offset to the terminating expression. &lt;/p&gt;&lt;p&gt; When response.getline() returns, the variable $1 is updated to point to the start of the next line in the datastream. &lt;/p&gt;&lt;p&gt; You can iterate through the lines of response data by using $1 as the iterator variable. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.get" />
                  <related func="request.getLine" />
               </relatedFunctions>
            </func>
            <func name="response.getLocalIP">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.getLocalIP returns the local IP address of the connection to the node in use, i.e. an IP address on the local machine that ZXTM connected from. It returns the empty string if no connection exists. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getLocalPort" />
                  <related func="response.getRemoteIP" />
                  <related func="response.getRemotePort" />
                  <related func="request.getLocalIP" />
                  <related func="request.getLocalPort" />
                  <related func="request.getRemoteIP" />
                  <related func="request.getRemotePort" />
               </relatedFunctions>
            </func>
            <func name="response.getLocalPort">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.getLocalPort returns the local port of the connection to the node in use, i.e. the port number on the local machine that ZXTM connected from. It returns 0 if there is no current connection to a node. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getLocalIP" />
                  <related func="response.getRemotePort" />
                  <related func="response.getRemoteIP" />
                  <related func="request.getLocalPort" />
                  <related func="request.getLocalIP" />
                  <related func="request.getRemotePort" />
                  <related func="request.getRemoteIP" />
               </relatedFunctions>
            </func>
            <func name="response.getRemoteIP">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.getRemoteIP returns the remote IP address of the node used. If there is no current connection, it will return an empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getRemotePort" />
                  <related func="response.getLocalIP" />
                  <related func="response.getLocalPort" />
                  <related func="request.getRemoteIP" />
                  <related func="request.getRemotePort" />
                  <related func="request.getLocalIP" />
                  <related func="request.getLocalPort" />
               </relatedFunctions>
            </func>
            <func name="response.getRemotePort">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; response.getRemotePort returns the network port number that ZXTM connected to a node. (e.g. port 80 is normal for a web server). If there is no current connection, it will return 0. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getRemoteIP" />
                  <related func="response.getLocalPort" />
                  <related func="response.getLocalIP" />
                  <related func="request.getRemotePort" />
                  <related func="request.getRemoteIP" />
                  <related func="request.getLocalPort" />
                  <related func="request.getLocalIP" />
               </relatedFunctions>
            </func>
            <func name="response.getToS">
               <parameters min="0" max="0" regex="">
                  <param name="Type of Service" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.getToS returns the Type of Service (ToS) of traffic going to the client. The return value is either "LOWDELAY", "THROUGHPUT", "RELIABILITY" or "NONE". &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getToS" />
                  <related func="response.setToS" />
               </relatedFunctions>
            </func>
            <func name="response.getfd">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.getfd() returns the number of the file descriptor used for communication with the back-end node. It returns -1 on failure. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.getfd" />
               </relatedFunctions>
            </func>
            <func name="response.set">
               <parameters min="1" max="1" regex=".">
                  <param name="response data" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.set() sets the server response to the provided string &lt;/p&gt;&lt;p&gt; This is a low-level routine that should be used with care. For protocols with their own higher-level protocol managers (e.g. http), use the higher level routines to alter the input data (e.g. http.setHeader() and http.setBody()). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.sendResponse" />
                  <related func="response.append" />
                  <related func="response.get" />
                  <related func="request.set" />
               </relatedFunctions>
            </func>
            <func name="response.setBandwidthClass">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_BW" />
                  <restriction type="ZXTM_TCP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; response.setBandwidthClass() sets the bandwidth class for the current connection to the client. Providing an empty class name removes the bandwidth class from the connection. It returns zero if an error occurs (for example, if the bandwidth class does not exist), and 1 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="response.getBandwidthClass" />
                  <related func="request.getBandwidthClass" />
                  <related func="request.setBandwidthClass" />
               </relatedFunctions>
            </func>
            <func name="response.setToS">
               <parameters min="1" max="1" regex=".">
                  <param name="Type of Service" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; response.setTos sets the Type of Service (ToS) of traffic going to the client to either "LOWDELAY", "THROUGHPUT", "RELIABILITY" or "NONE". &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="request.setToS" />
                  <related func="response.getToS" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="rtsp">
         <description>RTSP protocol-specific functions.</description>
         <functions>
            <func name="rtsp.addRequestHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.addRequestHeader() modifies the current RTSP request, adding an RTSP header with the supplied value. If the header already exists, then this value will be appended to the existing value. The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setRequestHeader" />
                  <related func="rtsp.getRequestHeader" />
                  <related func="rtsp.removeRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.addResponseHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.addResponseHeader() adds an RTSP header to the RTSP response that will be sent back to the client. If the header already exists in the response, then this value will be appended to the existing value. The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setResponseHeader" />
                  <related func="rtsp.getResponseHeader" />
                  <related func="rtsp.removeResponseHeader" />
                  <related func="rtsp.addRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getMethod">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getMethod() returns the RTSP method that was used to make the request, such as SETUP or PLAY. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setMethod" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getPath">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getPath() returns the %-decoded path in the RTSP request URL &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setPath" />
                  <related func="rtsp.getRawURL" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getRawURL">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getRawURL() returns the raw URL data provided by the client in the first line of the RTSP request, after the method and before the RTSP version specifier. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="rtsp.getRequest">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getRequest() returns the full RTSP request and headers, but does not include any body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getRequestHeaderNames" />
                  <related func="rtsp.getRequestHeader" />
                  <related func="rtsp.getRequestBody" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getRequestBody">
               <parameters min="0" max="1" regex=".?">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getRequestBody() returns the body data of the request. &lt;/p&gt;&lt;p&gt; If the optional 'count' parameter is supplied, rtsp.getRequestBody() will only read and return this number of bytes. If count is 0, rtsp.getRequestBody() returns the entire request. &lt;/p&gt;&lt;p&gt; If the request has no body, then this returns an empty string. This function is not useable in response rules, as the body data of the request will no longer be accessible. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getResponseBody" />
                  <related func="rtsp.setRequestBody" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getRequestHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getRequestHeader() returns the value of a named RTSP header in the RTSP request, or the empty string if the header does not exist or has an empty value. The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setRequestHeader" />
                  <related func="rtsp.addRequestHeader" />
                  <related func="rtsp.removeRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getRequestHeaderNames">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getRequestHeaderNames() returns a list of all the headers that are present in the request. &lt;/p&gt;&lt;p&gt; The headers are returned as a single string, separated by spaces. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="rtsp.getResponse">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getResponse() returns the full RTSP response and headers, but does not include any body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getResponseHeaderNames" />
                  <related func="rtsp.getResponseHeader" />
                  <related func="rtsp.getResponseBody" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getResponseBody">
               <parameters min="0" max="1" regex=".?">
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getResponseBody() returns the body of the RTSP response. This could be an SDP response. &lt;/p&gt;&lt;p&gt; If the optional 'count' parameter is provided, rtsp.getResponseBody() will read and return the first 'count' bytes of the response. If count is 0, rtsp.getResponseBody() will return the entire response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getRequestBody" />
                  <related func="rtsp.setResponseBody" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getResponseCode">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getResponseCode() returns the status code from the first line of the RTSP response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setResponseCode" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getResponseHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getResponseHeader() returns the value of a named RTSP header in the RTSP response, or the empty string if the header does not exist or has an empty value. The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setResponseHeader" />
                  <related func="rtsp.addResponseHeader" />
                  <related func="rtsp.removeResponseHeader" />
                  <related func="rtsp.responseHeaderExists" />
                  <related func="rtsp.getRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getResponseHeaderNames">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getResponseHeaderNames() returns a list of all the headers that are present in the response. &lt;/p&gt;&lt;p&gt; The headers are returned as a single string, separated by spaces. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getResponseHeader" />
                  <related func="rtsp.removeResponseHeader" />
                  <related func="rtsp.getRequestHeaderNames" />
               </relatedFunctions>
            </func>
            <func name="rtsp.getVersion">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.getVersion() returns the version of the RTSP protocol being used. It returns the version string in the RTSP/version specifier in the first line of the RTSP request, such as 'RTSP/1.0'. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="rtsp.redirect">
               <parameters min="1" max="1" regex=".">
                  <param name="path" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.redirect( path ) sends back an RTSP 302 redirect response, which will send the client to a different URL. This is equivalent to rtsp.sendResponse( "302 Moved Temporarily", "", "Location: " . $url ); &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.sendResponse" />
               </relatedFunctions>
            </func>
            <func name="rtsp.removeRequestHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.removeRequestHeader() removes a named header if it exists in the request. The header name is automatically translated to the correct case. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setRequestHeader" />
                  <related func="rtsp.getRequestHeader" />
                  <related func="rtsp.addRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.removeResponseHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.removeResponseHeader() removes the named RTSP header from the RTSP response. The header name is automatically translated to the correct case. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.setResponseHeader" />
                  <related func="rtsp.getResponseHeader" />
                  <related func="rtsp.addResponseHeader" />
                  <related func="rtsp.removeRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.requestHeaderExists">
               <parameters min="1" max="1" regex=".">
                  <param name="names" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.requestHeaderExists() determines if a named header exists or not. It is similar to rtsp.getRequestHeader(), but makes it possible to distinguish between a header not being present and a header having no value. &lt;/p&gt;&lt;p&gt; The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;&lt;p&gt; It returns 1 if the header exists, and 0 if it does not. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="rtsp.responseHeaderExists">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.responseHeaderExists() determines if a named header exists in the RTSP response. It is similar to rtsp.getResponseHeader(), but makes it possible to distinguish between a header not being present and a header having no value. &lt;/p&gt;&lt;p&gt; The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;&lt;p&gt; It returns 1 if the header exists, and 0 if it does not. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getResponseHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.sendResponse">
               <parameters min="3" max="3" regex="...">
                  <param name="code" />
                  <param name="body" />
                  <param name="headers" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.sendResponse() sends back an RTSP response to the client instead of balancing the request via a pool onto a node. It generates a correct RTSP response from the response code, body data and headers supplied. Multiple headers should be separated with \r\n. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="rtsp.setMethod">
               <parameters min="1" max="1" regex=".">
                  <param name="method" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.setMethod() sets the RTSP method to use when forwarding the request via a pool to a node. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getMethod" />
               </relatedFunctions>
            </func>
            <func name="rtsp.setPath">
               <parameters min="1" max="1" regex=".">
                  <param name="url" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.setPath() replaces the Path portion of the request URL with the supplied value. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getPath" />
               </relatedFunctions>
            </func>
            <func name="rtsp.setRequestBody">
               <parameters min="1" max="1" regex=".">
                  <param name="body" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
               </restrictions>
               <description>&lt;p&gt; rtsp.setRequestBody() sets the request body for this RTSP request to the supplied string, replacing any request body already present. &lt;/p&gt;&lt;p&gt; This also updates the 'Content-Length' header in the request to the length of the new body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getRequestBody" />
                  <related func="rtsp.setResponseBody" />
               </relatedFunctions>
            </func>
            <func name="rtsp.setRequestHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.setRequestHeader() sets the value of the named RTSP header, replacing any existing value if the header already exists. &lt;/p&gt;&lt;p&gt; Note that this function should not be used with the Connection header, i.e. setRequestHeader("Connection", value) since it may not give the expected results. &lt;/p&gt;&lt;p&gt; The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getRequestHeader" />
                  <related func="rtsp.addRequestHeader" />
                  <related func="rtsp.removeRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="rtsp.setResponseBody">
               <parameters min="1" max="1" regex=".">
                  <param name="body" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
               </restrictions>
               <description>&lt;p&gt; rtsp.setResponseBody() sets the response body for this RTSP response to the supplied string, replacing any response body already present. &lt;/p&gt;&lt;p&gt; This also updates the 'Content-Length' header in the response to the length of the new body data. If the server is still sending the original response body when this function is called, the connection to the server will be harmlessly dropped. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getResponseBody" />
                  <related func="rtsp.setRequestBody" />
               </relatedFunctions>
            </func>
            <func name="rtsp.setResponseCode">
               <parameters min="1" max="2" regex=".|..">
                  <param name="code" />
                  <param name="message" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.setResponseCode() sets the status code and message in the first line of the RTSP response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.getResponseCode" />
               </relatedFunctions>
            </func>
            <func name="rtsp.setResponseHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_RTSP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; rtsp.setResponseHeader() sets a RTSP header in the RTSP response that will be sent back to the client. If the header already exists in the response, then it will be replaced with this new value. &lt;/p&gt;&lt;p&gt; Note that this function should not be used with the Connection header, i.e. setResponseHeader("Connection", value) since it may not give the expected results. &lt;/p&gt;&lt;p&gt; The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="rtsp.addResponseHeader" />
                  <related func="rtsp.getResponseHeader" />
                  <related func="rtsp.removeResponseHeader" />
                  <related func="rtsp.setRequestHeader" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="rule">
         <description>Functions relating to this rule.</description>
         <functions>
            <func name="rule.getName">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; rule.getName returns the name of the currently executing rule. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="rule.getState">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_CORE" />
               </restrictions>
               <description>&lt;p&gt; returns the state of the currently executing rule, either REQUEST or RESPONSE. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="sip">
         <description>SIP protocol-specific functions.</description>
         <functions>
            <func name="sip.addRequestHeader">
               <parameters min="3" max="3" regex="...">
                  <param name="name" />
                  <param name="value" />
                  <param name="at_top" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.addRequestHeader() modifies the current SIP request, adding a SIP header with the supplied value. If the header already exists, then this value will be appended to the existing value. If at_top is set then the value will be prepended to the header. The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setRequestHeader" />
                  <related func="sip.getRequestHeader" />
                  <related func="sip.removeRequestHeader" />
                  <related func="sip.requestHeaderExists" />
               </relatedFunctions>
            </func>
            <func name="sip.addResponseHeader">
               <parameters min="3" max="3" regex="...">
                  <param name="name" />
                  <param name="value" />
                  <param name="at_top" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.addResponseHeader() adds a header to the SIP response that will be sent back to the client. If the header already exists in the response, then this value will be appended to the existing value. If at_top is set then the value will be prepended to the existing value. The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setResponseHeader" />
                  <related func="sip.getResponseHeader" />
                  <related func="sip.removeResponseHeader" />
                  <related func="sip.addRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.getMethod">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getMethod() returns the SIP method that was used to make the request, such as INVITE or REGISTER. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setMethod" />
               </relatedFunctions>
            </func>
            <func name="sip.getRequest">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.getRequest() returns the full SIP request and headers, but does not include any body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getRequestHeaderNames" />
                  <related func="sip.getRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.getRequestBody">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getRequestBody() returns the data contained in the body of the request. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setRequestBody" />
                  <related func="sip.getResponseBody" />
               </relatedFunctions>
            </func>
            <func name="sip.getRequestHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getRequestHeader() returns the value of a named SIP header in the SIP request, or the empty string if the header does not exist or has an empty value. The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setRequestHeader" />
                  <related func="sip.addRequestHeader" />
                  <related func="sip.removeRequestHeader" />
                  <related func="sip.requestHeaderExists" />
               </relatedFunctions>
            </func>
            <func name="sip.getRequestHeaderNames">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.getRequestHeaderNames() returns a list of all the headers that are present in the request. &lt;/p&gt;&lt;p&gt; The headers are returned as a single string, separated by spaces. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getRequestHeader" />
                  <related func="sip.removeRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.getRequestURI">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getRequestURI() returns the target of the SIP request. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setRequestURI" />
               </relatedFunctions>
            </func>
            <func name="sip.getResponse">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.getRequest() returns the full SIP response and headers, but does not include any body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getResponseHeaderNames" />
                  <related func="sip.getResponseHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.getResponseBody">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getResponseBody() returns the session description of the SIP response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setResponseBody" />
                  <related func="sip.getRequestBody" />
               </relatedFunctions>
            </func>
            <func name="sip.getResponseCode">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getResponseCode() returns the status code from the first line of the SIP response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setResponseCode" />
               </relatedFunctions>
            </func>
            <func name="sip.getResponseHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getResponseHeader() returns the value of a named SIP header in the SIP response, or the empty string if the header does not exist or has an empty value. The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setResponseHeader" />
                  <related func="sip.addResponseHeader" />
                  <related func="sip.removeResponseHeader" />
                  <related func="sip.responseHeaderExists" />
                  <related func="sip.getRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.getResponseHeaderNames">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.getResponseHeaderNames() returns a list of all the headers that are present in the response. &lt;/p&gt;&lt;p&gt; The headers are returned as a single string, separated by spaces. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getResponseHeader" />
                  <related func="sip.removeResponseHeader" />
                  <related func="sip.getRequestHeaderNames" />
               </relatedFunctions>
            </func>
            <func name="sip.getVersion">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.getVersion() returns the version of the SIP protocol being used. It returns the version string in the SIP/version specifier in the first line of the SIP request, such as 'SIP/2.0'. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="sip.redirect">
               <parameters min="1" max="1" regex=".">
                  <param name="contact" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.redirect( contact ) sends back a 302 Moved Temporarily response. This response instructs the client to retry the request at the new address(es) given in the 'contact' parameter. This is equivalent to sip.sendResponse( "302", "Moved Temporarily", "Contact: " . $uri, "" ); &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.sendResponse" />
               </relatedFunctions>
            </func>
            <func name="sip.removeRequestHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.removeRequestHeader() removes a named header if it exists in the request. The header name is automatically translated to the correct case. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getRequestHeader" />
                  <related func="sip.addRequestHeader" />
                  <related func="sip.setRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.removeResponseHeader">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.removeResponseHeader() removes the named SIP header from the SIP response. The header name is automatically translated to the correct case. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.setResponseHeader" />
                  <related func="sip.getResponseHeader" />
                  <related func="sip.addResponseHeader" />
                  <related func="sip.removeRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.requestHeaderExists">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.requestHeaderExists() determines if a named header exists or not. It is similar to sip.getRequestHeader(), but makes it possible to distinguish between a header not being present and a header having no value. &lt;/p&gt;&lt;p&gt; The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;&lt;p&gt; It returns 1 if the header exists, and 0 if it does not. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.responseHeaderExists">
               <parameters min="1" max="1" regex=".">
                  <param name="name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.responseHeaderExists() determines if a named header exists in the SIP response. It is similar to sip.getResponseHeader(), but makes it possible to distinguish between a header not being present and a header having no value. &lt;/p&gt;&lt;p&gt; The header name is automatically translated into the proper case for the lookup. &lt;/p&gt;&lt;p&gt; It returns 1 if the header exists, and 0 if it does not. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getResponseHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.sendResponse">
               <parameters min="2" max="4" regex="..|...|....">
                  <param name="code" />
                  <param name="reason" />
                  <param name="headers" />
                  <param name="body" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.sendresponse() sends back a SIP response to the client instead of balancing the request via a pool onto a node. The Statue-Line of the response has the form: SIP/2.0 code reason Via, Record-Route, From, To, CSeq, Call-ID and Content-Length headers are automatically added to the response. Any headers supplied in the headers parameter will also be added to the response. Multiple headers must be separated by \r\n. Any body data specified is appended to the response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.redirect" />
               </relatedFunctions>
            </func>
            <func name="sip.setMethod">
               <parameters min="1" max="1" regex=".">
                  <param name="method" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.setMethod() sets the SIP method to use when forwarding the request via a pool to a node. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getMethod" />
               </relatedFunctions>
            </func>
            <func name="sip.setRequestBody">
               <parameters min="1" max="1" regex=".">
                  <param name="body" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.setRequestBody() sets the request body for this SIP request to the supplied string, replacing any request body already present. &lt;/p&gt;&lt;p&gt; This also updates the 'Content-Length' header in the request to the length of the new body data. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getRequestBody" />
               </relatedFunctions>
            </func>
            <func name="sip.setRequestHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.setRequestHeader() sets the value of the named SIP header, replacing any existing value if the header already exists. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.addRequestHeader" />
                  <related func="sip.getRequestHeader" />
                  <related func="sip.requestHeaderExists" />
                  <related func="sip.removeRequestHeader" />
               </relatedFunctions>
            </func>
            <func name="sip.setRequestURI">
               <parameters min="1" max="1" regex=".">
                  <param name="uri" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.setRequestURI() sets the target of the SIP request. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getRequestURI" />
               </relatedFunctions>
            </func>
            <func name="sip.setResponseBody">
               <parameters min="1" max="1" regex=".">
                  <param name="body" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.setResponseBody() sets the response body for this SIP response to the supplied string, replacing any response body already present. &lt;/p&gt;&lt;p&gt; This also updates the 'Content-Length' header in the response to the length of the new body data. If the server is still sending the original response body when this function is called, the connection to the server will be harmlessly dropped. &lt;/p&gt;&lt;p&gt; &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getResponseBody" />
                  <related func="sip.setRequestBody" />
               </relatedFunctions>
            </func>
            <func name="sip.setResponseCode">
               <parameters min="1" max="2" regex=".|..">
                  <param name="code" />
                  <param name="message" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
               </restrictions>
               <description>&lt;p&gt; sip.setResponseCode() sets the status code and message in the first line of the SIP response. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.getResponseCode" />
               </relatedFunctions>
            </func>
            <func name="sip.setResponseHeader">
               <parameters min="2" max="2" regex="..">
                  <param name="name" />
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SIP" />
                  <restriction type="ZXTM_RB" />
               </restrictions>
               <description>&lt;p&gt; sip.setResponseHeader() sets a header in the SIP response that will be sent back to the client. If the header already exists in the response, then it will be replaced with this new value. &lt;/p&gt;&lt;p&gt; The header name is automatically translated to the correct case before it is added. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sip.addResponseHeader" />
                  <related func="sip.getResponseHeader" />
                  <related func="sip.removeResponseHeader" />
                  <related func="sip.setRequestHeader" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="slm">
         <description>Functions for accessing information from the Service Level Monitoring class assigned to this connection.</description>
         <functions>
            <func name="slm.conforming">
               <parameters min="0" max="1" regex=".?">
                  <param name="class name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SLM" />
               </restrictions>
               <description>&lt;p&gt; slm.conforming() returns the current percentage of requests that are meeting the Service Level Monitoring objectives. If no class name is provided, it will use the SLM class currently associated with this connection; if no SLM class is associated with this connection, it returns 100. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="slm.threshold" />
                  <related func="slm.isOK" />
               </relatedFunctions>
            </func>
            <func name="slm.isOK">
               <parameters min="0" max="1" regex=".?">
                  <param name="class_name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SLM" />
               </restrictions>
               <description>&lt;p&gt; slm.isOK() returns whether a particular Service Level Monitoring class is meeting its objectives. If no class name is provided, it will use the SLM class currently associated with this connection; if no SLM class is associated with the connection, it returns 1. This function is a convenience shorthand for 'slm.conforming() &gt; slm.threshold()'. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="slm.conforming" />
                  <related func="slm.threshold" />
               </relatedFunctions>
            </func>
            <func name="slm.threshold">
               <parameters min="0" max="1" regex=".?">
                  <param name="class_name" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_SLM" />
               </restrictions>
               <description>&lt;p&gt; slm.threshold() returns the percentage of connections that need to meet the Service Level Monitoring alert threshold for the SLM class to be considered OK. If no class name is provided, it will use the SLM class currently associated with this connection; if no SLM class is associated with the connection, it returns 0. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="slm.conforming" />
                  <related func="slm.isOK" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="ssl">
         <description>Functions relating to the encryption applied to the current connection.</description>
         <functions>
            <func name="ssl.clientCert">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCert() returns the PEM encoded client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertAlgorithm">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; If the connection is SSL-encrypted and the client has supplied a valid certificate, ssl.clientCertAlgorithm() returns either 'rsaEncryption', 'md2withRSAEncryption', 'md5withRSAEncryption', 'sha1withRSAEncryption' or 'RSA', depending on the certificate's encryption and hash algorithms. Otherwise, it returns the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertEndDate">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; If the connection is SSL-encrypted and the client has supplied a valid certificate, ssl.clientCertEndDate() returns the date when the certificate is no longer valid. The date is an integer, representing seconds since the epoch. &lt;/p&gt;&lt;p&gt; Otherwise, this function returns 0. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.clientCertStartDate" />
                  <related func="sys.timeToString" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertHash">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCertHash() returns a hex-encoded MD5 hash of the client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertIssuer">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCertIssuer() returns a string representing the issuer of the client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertPublicKey">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCertPublicKey() returns a string representation of the public key of the client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertSerial">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; This function returns the serial (in hex) of the client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.clientCertSerialDec" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertSerialDec">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; This function returns the serial (in decimal) of the client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.clientCertSerial" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertStartDate">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; If the connection is SSL-encrypted and the client has supplied a valid certificate, ssl.clientCertStartDate() returns the date when the certificate became valid. The date is an integer, representing seconds since the epoch. &lt;/p&gt;&lt;p&gt; Otherwise, this function returns 0. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.clientCertEndDate" />
                  <related func="sys.timeToString" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertStatus">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCertStatus() returns 'OK' if the client certificate is valid, or 'NoClientCert' if it was missing or not valid. It returns the empty string if the connection was not SSL-encrypted. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertSubject">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCertSubject() returns a string representing the subject of the client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCertVersion">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCertVersion() returns "1", "2" or "3" denoting the version of the client certificate, or the empty string if the connection was not SSL-encrypted or if a certificate was not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.clientCipher">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.clientCipher() returns the cipher used by the client to SSL-encrypt the connection. It returns an empty string if the connection was not SSL-encrypted. &lt;/p&gt;&lt;p&gt; The string returned contains the cipher algorithm, SSL version and effective cipher strength, such as: &lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;SSL_RSA_WITH_RC4_128_SHA, version=SSLv3, bits=128 &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.getClientCloseAlert">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.getClientCloseAlert() can be used to check whether the ZXTM will send the SSL client an SSL close alert prior to terminating the TCP connection. The function will return a value of 1 if close alerts are enabled, and 0 if they are disabled. The function will return -1 if the client-side connection is not established, or is not an SSL connection. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.setClientCloseAlert" />
                  <related func="ssl.setServerCloseAlert" />
                  <related func="ssl.getServerCloseAlert" />
               </relatedFunctions>
            </func>
            <func name="ssl.getServerCloseAlert">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.getServerCloseAlert() can be used to check whether the ZXTM will send the SSL server an SSL close alert prior to terminating the TCP connection. The function will return a value of 1 if close alerts are enabled, and 0 if they are disabled. The function will return -1 if the connection is not an SSL connection, or if the server-side connection is not yet established (i.e. it should typically only be used in response rules.) &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.setServerCloseAlert" />
                  <related func="ssl.setClientCloseAlert" />
                  <related func="ssl.getClientCloseAlert" />
               </relatedFunctions>
            </func>
            <func name="ssl.getTLSServerName">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.getTLSServerName() returns the hostname provided by the client using the TLS 1.0 'server_name' extension. If this connection is not using SSL decryption or the client did use the extension this function returns the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.setTLSServerName" />
               </relatedFunctions>
            </func>
            <func name="ssl.isSSL">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.isSSL() returns 1 if this connection from the remote client was SSL encrypted and ZXTM has decrypted the traffic. Otherwise, it returns 0. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="ssl.serverCert">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCert() returns a string with a PEM encoded version of the entire certificate being used by ZXTM for this connection. If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertAlgorithm">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertAlgorithm() returns a string with a description of the algorithms being used by the virtual server's current certificate. This will either be 'rsaEncryption', 'md2withRSAEncryption', 'md5withRSAEncryption', 'sha1withRSAEncryption' or 'RSA'. If this virtual server is not using SSL decryption (or the algorithm type is not recognised) this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertCommonName">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertCommonName() returns a string with the common name of the certificate being used by ZXTM for this connection. If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertEndDate">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertEndDate() returns the date the certificate being used by ZXTM for this connection became valid. The date is an integer, representing the number of seconds since the epoch. If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.serverCertStartDate" />
                  <related func="sys.time" />
                  <related func="sys.timeToString" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertHash">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertHash() returns the hex-encoded MD5 hash of the certificate being used by ZXTM for this connection. If this virtual server is not using SSL decryption this function will the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertIssuer">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertIssuer() returns with a string with the issuer data of the certificate being used by ZXTM for this connection (each field is separated by commas). If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.serverCertSubject" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertName">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertName() returns the name of the certificate being used by the virtual server for this connection. This is the name used to identify the certificate in the UI. If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertPublicKey">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertPublicKey() returns a string with information about the public key of the certificate being used by ZXTM for this connection. If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertSerial">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertSerial() returns a string with the serial number (in hex) of the certificate being used by ZXTM for this connection. If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertStartDate">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertStartDate() returns the date the certificate being used by ZXTM for this connection became valid. The date is an integer, representing the number of seconds since the epoch. If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.serverCertEndDate" />
                  <related func="sys.time" />
                  <related func="sys.timeToString" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertSubject">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertSubject() returns a string with the subject data of the certificate being used by ZXTM for this connection (each field is separated by commas). If this virtual server is not using SSL decryption this function will return the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.serverCertIssuer" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverCertVersion">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverCertVersion() returns the version of the certificate being used by ZXTM for this connection (either "1", "2" or "3"). If this virtual server is not using SSL decryption this function will the empty string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.serverSiteName">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.serverSiteName() returns the hostname or IP address that was used to select the current server certificate. If the default certificate was used, or the current connection is not encrypted, the empty string is returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
            <func name="ssl.setClientCloseAlert">
               <parameters min="1" max="1" regex=".">
                  <param name="alertflag" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.setClientCloseAlert() can be used to set whether the ZXTM will send the SSL client an SSL close alert prior to terminating the TCP connection. An argument with an integer value of 0 will disable close alerts, a non-zero argument will enable close alerts. This setting also applies to related connections, such as data transfer channels related to FTP command channels. If the connection with the client is not an SSL connection then calling this function will do nothing. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.getClientCloseAlert" />
                  <related func="ssl.setServerCloseAlert" />
                  <related func="ssl.getServerCloseAlert" />
               </relatedFunctions>
            </func>
            <func name="ssl.setServerCloseAlert">
               <parameters min="1" max="1" regex=".">
                  <param name="alertflag" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.setServerCloseAlert() can be used to set whether the ZXTM will send the SSL server an SSL close alert prior to terminating the TCP connection. An argument with an integer value of 0 will disable close alerts, a non-zero argument will enable close alerts. This setting also applies to related connections, such as data transfer channels related to FTP command channels. Note that this function will only work on SSL connections and the server side connection must be established (i.e. it should typically only be used in response rules.) &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.getServerCloseAlert" />
                  <related func="ssl.setClientCloseAlert" />
                  <related func="ssl.getClientCloseAlert" />
               </relatedFunctions>
            </func>
            <func name="ssl.setTLSServerName">
               <parameters min="1" max="1" regex=".">
                  <param name="servername" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.setTLSServerName() tells ZXTM to use the hostname specified when using the TLS 1.0 server_name extension. This method only works if the back end pool has SSL encryption and the server_name option enabled. Using the empty string as this function's parameter will make ZXTM use the hostname of the node it is connecting to. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
                  <related func="ssl.getTLSServerName" />
               </relatedFunctions>
            </func>
            <func name="ssl.sslSessionID">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="ZXTM_TCP" />
               </restrictions>
               <description>&lt;p&gt; ssl.sslSessionID() returns the session-id of the current SSL connection, or the empty string if the connection was not SSL-encrypted. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="ssl.isSSL" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="string">
         <description>Functions for manipulating and encoding strings.</description>
         <functions>
            <func name="string.BERToInt">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.BERToInt() converts a BER compressed integer into an integer. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.intToBER" />
                  <related func="string.bytesToInt" />
               </relatedFunctions>
            </func>
            <func name="string.Ireplace">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="search" />
                  <param name="replacement" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; string.Ireplace() replaces the first occurrence of the search string in the supplied string with the replacement. It is case-insensitive and returns the string with the replacement. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by string.replaceI&lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="string.IreplaceAll">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="search" />
                  <param name="replacement" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; string.IreplaceAll() replaces all occurrences of the search string in the supplied string with the replacement. It is case-insensitive and returns the string with the replacements. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by string.replaceAllI&lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="string.append">
               <parameters min="1" max="INF" regex=".+">
                  <param name="str1" />
                  <param name="str2" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.append() takes any number of parameters. It interprets each as a string and returns the result of concatenating them all together. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="string.base64decode">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.base64decode() decodes a base64-encoded string and returns the result. &lt;/p&gt;&lt;p&gt; Base64 encoding is used for MIME-encoded messages, and in the HTTP Basic Authorization header. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.base64encode" />
                  <related func="string.hexdecode" />
                  <related func="string.unescape" />
               </relatedFunctions>
            </func>
            <func name="string.base64encode">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.base64encode() returns the base64-encoded version of the provided string. This converts each group of three characters into a 4-character string containing just [A-Za-z0-9+/], and '=' for padding. &lt;/p&gt;&lt;p&gt; Base64 encoding is used for MIME-encoded messages, and in the HTTP Basic Authorization header. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.base64decode" />
                  <related func="string.hexencode" />
                  <related func="string.escape" />
               </relatedFunctions>
            </func>
            <func name="string.bytesToDotted">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.bytesToDotted() converts a network ordered byte string into an IP address. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.dottedToBytes" />
                  <related func="string.bytesToInt" />
               </relatedFunctions>
            </func>
            <func name="string.bytesToInt">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.bytesToInt() converts a byte string in network order to an integer. The byte string should be either 1, 2 or 4 bytes long. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.intToBytes" />
                  <related func="string.bytesToDotted" />
                  <related func="string.BERToInt" />
               </relatedFunctions>
            </func>
            <func name="string.cmp">
               <parameters min="2" max="2" regex="..">
                  <param name="str1" />
                  <param name="str2" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.cmp() compares its two parameters as strings in a case-sensitive manner. It returns a negative value if str1 is less than str2; zero if they are equal, and a positive value if str1 is greater than str2. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.icmp" />
               </relatedFunctions>
            </func>
            <func name="string.contains">
               <parameters min="2" max="2" regex="..">
                  <param name="haystack" />
                  <param name="needle" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.contains() determines whether the provided search string (the needle) is contained inside the given string (the haystack). &lt;/p&gt;&lt;p&gt; It returns 1 if the 'needle' was found, or 0 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.containsI" />
                  <related func="string.find" />
                  <related func="string.findr" />
                  <related func="string.startsWith" />
                  <related func="string.endsWith" />
               </relatedFunctions>
            </func>
            <func name="string.containsI">
               <parameters min="2" max="2" regex="..">
                  <param name="haystack" />
                  <param name="needle" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.containsI() determines whether the provided search string (the needle) is contained inside the given string (the haystack). It is case-insensitive. &lt;/p&gt;&lt;p&gt; It returns 1 if the 'needle' was found, or 0 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.contains" />
                  <related func="string.findI" />
                  <related func="string.startsWithI" />
                  <related func="string.endsWithI" />
               </relatedFunctions>
            </func>
            <func name="string.count">
               <parameters min="2" max="3" regex="..|...">
                  <param name="haystack" />
                  <param name="needle" />
                  <param name="start" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.count() searches from the start of a string, counting the number of times that the provided search string (the needle) is found inside the given string (the haystack). An optional parameter can specify the start position for the search. &lt;/p&gt;&lt;p&gt; It returns the number of times that the string is found. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.find" />
                  <related func="string.contains" />
               </relatedFunctions>
            </func>
            <func name="string.decrypt">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="passphrase" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.decrypt() decrypts a string that has previously been encrypted using string.encrypt(). The passphrase supplied must match that given to string.encrypt(), otherwise the decoding will fail. &lt;/p&gt;&lt;p&gt; An empty string is returned if the decrypt or the integrity check fails. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.encrypt" />
               </relatedFunctions>
            </func>
            <func name="string.dottedToBytes">
               <parameters min="1" max="1" regex=".">
                  <param name="IP address" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.dottedToBytes() converts an IP address to a network order byte string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.bytesToDotted" />
                  <related func="string.intToBytes" />
               </relatedFunctions>
            </func>
            <func name="string.drop">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.drop() removes the last 'count' characters from the end of the provided string and returns the result. An empty string will be returned if 'count' is greater than the length of the original string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.skip" />
                  <related func="string.trim" />
               </relatedFunctions>
            </func>
            <func name="string.encrypt">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="passphrase" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.encrypt() encrypts a string using the provided pass phrase. The string is encrypted using the AES block cipher, using an expanded form of the passphrase as the cipher key. A MAC is also added to ensure the integrity of the string. &lt;/p&gt;&lt;p&gt; This is open to replay attacks, and as such, should not be used to encrypt sensitive data, such as credit card details. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.decrypt" />
               </relatedFunctions>
            </func>
            <func name="string.endsWith">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="suffix" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.endsWith() returns 1 if the provided string ends with the given suffix, and 0 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.endsWithI" />
                  <related func="string.startsWith" />
                  <related func="string.contains" />
               </relatedFunctions>
            </func>
            <func name="string.endsWithI">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="suffix" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.endsWithI() returns 1 if the provided string ends with the given suffix, and 0 otherwise. It is case-insensitive. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.endsWith" />
                  <related func="string.startsWithI" />
                  <related func="string.containsI" />
               </relatedFunctions>
            </func>
            <func name="string.escape">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.escape() returns a percent-encoded version of its parameter. &lt;/p&gt;&lt;p&gt; Control characters and spaces (character value &lt;= 32) and '%' characters are each replaced by a '%' symbol, followed by their 2-digit hex value. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.unescape" />
                  <related func="string.hexencode" />
                  <related func="string.regexescape" />
                  <related func="string.urlencode" />
               </relatedFunctions>
            </func>
            <func name="string.extractHost">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.extractHost() returns the host part of the supplied address if it is a valid IP or hostname. The empty string is returned otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.extractPort" />
               </relatedFunctions>
            </func>
            <func name="string.extractPort">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.extractPort() returns the port part of the supplied address if both the host and port of the supplied address are valid. The empty string is returned otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.extractHost" />
               </relatedFunctions>
            </func>
            <func name="string.find">
               <parameters min="2" max="3" regex="..|...">
                  <param name="haystack" />
                  <param name="needle" />
                  <param name="start" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.find() determines whether the provided search string (the needle) is contained inside the given string (the haystack). An optional parameter can specify the start position for the search. &lt;/p&gt;&lt;p&gt; It returns the location of the first instance of the search string; note that character positions start at 0. &lt;/p&gt;&lt;p&gt; If it could not find the search string, it returns -1. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.findI" />
                  <related func="string.findr" />
                  <related func="string.contains" />
               </relatedFunctions>
            </func>
            <func name="string.findI">
               <parameters min="2" max="3" regex="..|...">
                  <param name="haystack" />
                  <param name="needle" />
                  <param name="start" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.findI() determines whether the provided search string (the needle) is contained inside the given string (the haystack). An optional parameter can specify the start position for the search. It is case-insensitive. &lt;/p&gt;&lt;p&gt; It returns the location of the first instance of the search string; note that character positions start at 0. &lt;/p&gt;&lt;p&gt; If it could not find the search string, it returns -1. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.find" />
                  <related func="string.containsI" />
               </relatedFunctions>
            </func>
            <func name="string.findr">
               <parameters min="2" max="3" regex="..|...">
                  <param name="haystack" />
                  <param name="needle" />
                  <param name="distanceFromEndToStart" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.findr() searches from the end of a string, determining whether the provided search string (the needle) is contained inside the given string (the haystack). An optional parameter can specify the start position for the search, measured from the end of the string (so setting it to 1 skips the last character in the string). &lt;/p&gt;&lt;p&gt; It returns the location of the last instance of the search string; note that character positions start at 0. &lt;/p&gt;&lt;p&gt; If it could not find the search string, it returns -1. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.find" />
                  <related func="string.contains" />
               </relatedFunctions>
            </func>
            <func name="string.hashMD5">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.hashMD5() returns the MD5 hash of the provided string. The returned string will be 16 bytes long, and may contain non-printable characters. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.hexencode" />
                  <related func="string.hashSHA1" />
               </relatedFunctions>
            </func>
            <func name="string.hashSHA1">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.hashSHA1() returns the SHA1 hash of the provided string. The returned string will be 20 bytes long, and may contain non-printable characters. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.hexencode" />
                  <related func="string.hashMD5" />
               </relatedFunctions>
            </func>
            <func name="string.hexdecode">
               <parameters min="1" max="1" regex=".">
                  <param name="encoded string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.hexdecode() returns the hex-decoded version of the provided string. This interprets each character pair as a 2-digit hex value, replacing it with the corresponding 8-bit character. It does not verify that the original string was correctly encoded. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.hexencode" />
                  <related func="string.base64decode" />
                  <related func="string.unescape" />
               </relatedFunctions>
            </func>
            <func name="string.hexencode">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.hexencode() returns the hex-encoded version of the provided string . This converts each character into a two-character hex representation, doubling the length of the string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.hexdecode" />
                  <related func="string.base64encode" />
                  <related func="string.escape" />
               </relatedFunctions>
            </func>
            <func name="string.htmldecode">
               <parameters min="1" max="1" regex=".">
                  <param name="encodedstring" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.htmldecode() decodes HTML encodings such as &amp;amp;lt; and &amp;amp;quot; in the supplied string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.htmlencode" />
               </relatedFunctions>
            </func>
            <func name="string.htmlencode">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.htmlencode() encodes the supplied string to make it safe for including in HTML. It converts '&lt;' to &amp;amp;lt; '&gt;' to &amp;amp;gt;, '"' to &amp;amp;quot; and '&amp;' to &amp;amp;amp;. Control characters are hex-encoded. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.htmldecode" />
                  <related func="string.urlencode" />
               </relatedFunctions>
            </func>
            <func name="string.icmp">
               <parameters min="2" max="2" regex="..">
                  <param name="str1" />
                  <param name="str2" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.icmp() compares its two parameters as strings in a case-insensitive manner. It returns a negative value if str1 is less than str2; zero if they are equal, and a positive value if str1 is greater than str2. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.cmp" />
               </relatedFunctions>
            </func>
            <func name="string.insertBytes">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="insertion" />
                  <param name="offset" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.insertBytes() inserts a string into another string at the supplied offset, and returns the resulting string. If offset &lt; 0, or offset &gt; length( string ), the original string is returned unchanged. If offset == 0 the insertion string is prepended; if offset == length( string ) the insertion string is appended. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.replaceBytes" />
               </relatedFunctions>
            </func>
            <func name="string.intToBER">
               <parameters min="1" max="1" regex=".">
                  <param name="number" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.intToBER() converts an integer into a BER compressed integer (which is a variable-length binary string encoding). &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.BERToInt" />
                  <related func="string.intToBytes" />
               </relatedFunctions>
            </func>
            <func name="string.intToBytes">
               <parameters min="1" max="2" regex=".|..">
                  <param name="number" />
                  <param name="width" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.intToBytes() converts an integer to a network order byte string of the specified width. Only widths of 1, 2 and 4 are permitted, and the width defaults to 4 if it is not supplied. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.bytesToInt" />
                  <related func="string.bytesToDotted" />
                  <related func="string.intToBER" />
               </relatedFunctions>
            </func>
            <func name="string.ipmaskmatch">
               <parameters min="2" max="2" regex="..">
                  <param name="IP Address" />
                  <param name="CIDR IP Subnet" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.ipmaskmatch() returns 1 if the provided IP address is contained in the CIDR IP Subnet, and 0 otherwise. &lt;/p&gt;&lt;p&gt; It interprets its first parameter as a string containing an IP address, and its second parameter as an CIDR IP subnet. CIDR IP subnets can be of the form "10.0.1.0/24", "10.0.1.0/255.255.255.0", "10.0.1." or "10.0.1.1". &lt;/br&gt; &lt;/p&gt;&lt;p&gt; For IPv6, the standard notation of "2001:200:0:8002::/64" is supported. &lt;/br&gt; &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.validIPAddress" />
               </relatedFunctions>
            </func>
            <func name="string.left">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.left() returns the first 'count' characters of the provided string. An empty string will be returned if 'count' is less than or equal to zero. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.skip" />
               </relatedFunctions>
            </func>
            <func name="string.len">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.len() interprets its parameter as a string and returns its length (in bytes). &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="string.length">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; This function is an alias for string.len. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.len" />
               </relatedFunctions>
            </func>
            <func name="string.lowercase">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.lowercase() converts all characters in the provided string to lowercase and returns the result. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.uppercase" />
               </relatedFunctions>
            </func>
            <func name="string.normalizeIPAddress">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.normalizeipaddress() returns a unique string representation of an IP address: all leading zeros are removed, and for IPv6 addresses the first occurrence of blocks consisting entirely of zeros is replaced by "::". This normal form can be used to compare IP addresses without ambiguity and is also the form used by TrafficScript functions returning IP addresses. If the string is not a valid IP address, the empty string is returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.validIPAddress" />
               </relatedFunctions>
            </func>
            <func name="string.randomBytes">
               <parameters min="1" max="1" regex=".">
                  <param name="length" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.randomBytes() returns a string of the supplied length filled with random bytes. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="string.regexescape">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.regexescape() returns a version of its parameter suitable for using inside a regex match as a string literal &lt;/p&gt;&lt;p&gt; All characters in the string that aren't a-z, A-Z, 0-9 or '_' are escaped using a backslash. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.escape" />
               </relatedFunctions>
            </func>
            <func name="string.regexmatch">
               <parameters min="2" max="3" regex="...?">
                  <param name="string" />
                  <param name="regex" />
                  <param name="flags" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.regexmatch() performs a regular expression match on the supplied string. If the regular expression 'regex' contains bracketed sub-expressions, then the variables $1 ... $9 will be set to the matching substrings. &lt;/p&gt;&lt;p&gt; Note that the '\' character is an escape character in TrafficScript strings. If you need to put a literal '\' in a regular expression, you must escape it as '\\'. To match a literal string inside a regular expression use the string.regexscape function. &lt;/p&gt;&lt;p&gt; The optional 'flags' parameter contains a string of single-letter options. The following options are supported: &lt;ul&gt; &lt;li&gt;'i', meaning 'case insensitive' - letters in the pattern match both upper and lower case letters.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;&lt;p&gt; It returns 1 if matched, and 0 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.wildmatch" />
                  <related func="string.regexsub" />
                  <related func="string.regexescape" />
               </relatedFunctions>
            </func>
            <func name="string.regexsub">
               <parameters min="3" max="4" regex="...|....">
                  <param name="string" />
                  <param name="regex" />
                  <param name="replacement" />
                  <param name="flags" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.regexsub() performs a regular expression match on the supplied string, then replaces each matching substring with the supplied replacement. The replacement string may contain $1 .. $9 substitutions, which reference bracketed sub-expressions in the regular expression. &lt;/p&gt;&lt;p&gt; Note that the '\' character is an escape character in TrafficScript strings. If you need to put a literal '\' in a regular expression, you must escape it as '\\'. To match a literal string inside a regular expression use the string.regexscape function. &lt;/p&gt;&lt;p&gt; The optional 'flags' parameter contains a string of single-letter options. The following options are supported: &lt;ul&gt; &lt;li&gt;'g', meaning 'global replace' - apply the regex pattern as many times as possible.&lt;/li&gt; &lt;li&gt;'i', meaning 'case insensitive' - letters in the pattern match both upper and lower case letters.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;&lt;p&gt; string.regexsub() returns the string with the replacements. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.regexmatch" />
               </relatedFunctions>
            </func>
            <func name="string.replace">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="search" />
                  <param name="replacement" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.replace() replaces the first occurrence of the search string in the supplied string with the replacement. It is case-sensitive and returns the string with the replacement. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.replaceI" />
                  <related func="string.replaceAll" />
                  <related func="string.replaceAllI" />
               </relatedFunctions>
            </func>
            <func name="string.replaceAll">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="search" />
                  <param name="replacement" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.replaceAll() replaces all occurrences of the search string in the supplied string with the replacement. It is case-sensitive and returns the string with the replacements. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.replaceAllI" />
                  <related func="string.replace" />
                  <related func="string.replaceI" />
               </relatedFunctions>
            </func>
            <func name="string.replaceAllI">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="search" />
                  <param name="replacement" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.replaceAllI() replaces all occurrences of the search string in the supplied string with the replacement. It is case-insensitive and returns the string with the replacements. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.replaceAll" />
                  <related func="string.replaceI" />
                  <related func="string.replace" />
               </relatedFunctions>
            </func>
            <func name="string.replaceBytes">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="replacement" />
                  <param name="offset" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.replaceBytes() replaces a portion of a string with a replacement string at the supplied offset. It returns a modified version of the original string of the same length as the original with the appropriate bytes replaced from the replacement string. &lt;/p&gt;&lt;p&gt; If offset &lt; 0, or offset &gt; length( string ), or length( replacement ) == 0, string.replaceBytes returns the original string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.insertBytes" />
               </relatedFunctions>
            </func>
            <func name="string.replaceI">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="search" />
                  <param name="replacement" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.replaceI() replaces the first occurrence of the search string in the supplied string with the replacement. It is case-insensitive and returns the string with the replacement. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.replace" />
                  <related func="string.replaceAllI" />
                  <related func="string.replaceAll" />
               </relatedFunctions>
            </func>
            <func name="string.reverse">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.reverse() reverses the characters in a string and returns the result. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="string.right">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.right() returns the last 'count' characters of the provided string. An empty string will be returned if 'count' is less than or equal to zero. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.drop" />
               </relatedFunctions>
            </func>
            <func name="string.skip">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="count" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.skip() removes the first 'count' characters of the provided string and returns the result. An empty string will be returned if 'count' is greater than the length of the original string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.drop" />
                  <related func="string.trim" />
               </relatedFunctions>
            </func>
            <func name="string.sprintf">
               <parameters min="1" max="INF" regex=".+">
                  <param name="format string" />
                  <param name="arguments" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.snprintf() behaves like the C library sprintf() function. Only %s, %c, %d and %f are supported. The function returns the generated string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.append" />
               </relatedFunctions>
            </func>
            <func name="string.startsWith">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="prefix" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.startsWith() returns 1 if the provided string starts with the given prefix, and 0 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.startsWithI" />
                  <related func="string.endsWith" />
                  <related func="string.contains" />
               </relatedFunctions>
            </func>
            <func name="string.startsWithI">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="prefix" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.startsWithI() returns 1 if the provided string starts with the given prefix, and 0 otherwise. It is case-insensitive. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.startsWith" />
                  <related func="string.endsWithI" />
                  <related func="string.containsI" />
               </relatedFunctions>
            </func>
            <func name="string.substring">
               <parameters min="3" max="3" regex="...">
                  <param name="string" />
                  <param name="base" />
                  <param name="end" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.substring() returns the substring starting at character position 'base' and ending at position 'end'. &lt;/p&gt;&lt;p&gt; Note that character positions start at 0, and the end position is inclusive. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="string.trim">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.trim() returns the result of removing leading and trailing white space from its parameter. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.skip" />
                  <related func="string.drop" />
               </relatedFunctions>
            </func>
            <func name="string.unescape">
               <parameters min="1" max="1" regex=".">
                  <param name="escaped string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.unescape() returns the escape-decoded version of its parameter. &lt;/p&gt;&lt;p&gt; %-encoded characters are replaced with their decoded versions. %u-encoded characters are replaced with their UTF-8 representation. If there are illegal digits which cannot safely be converted, the variable $1 is set to 0 and the result contains '_' in place of the '%'. Such malicious %-escaped URLs are a common way of attacking unassuming servers or applications, and by handling them in this way, the attack is thwarted, but some information about a suspicious request is retained. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.escape" />
                  <related func="string.hexdecode" />
               </relatedFunctions>
            </func>
            <func name="string.uppercase">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.uppercase() converts all characters in the provided string to uppercase and returns the result. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.lowercase" />
               </relatedFunctions>
            </func>
            <func name="string.urlencode">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.urlencode() encodes the supplied string to make it safe for including in URLs. It converts unsafe characters to percent+hex form. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.unescape" />
                  <related func="string.htmlencode" />
               </relatedFunctions>
            </func>
            <func name="string.validIPAddress">
               <parameters min="1" max="1" regex=".">
                  <param name="string" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.validipaddress() returns 4 if the string provided is an IPv4 address, 6 if it is an IPv6 address and 0 if it is not a valid IP address. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.ipmaskmatch" />
               </relatedFunctions>
            </func>
            <func name="string.wildmatch">
               <parameters min="2" max="2" regex="..">
                  <param name="string" />
                  <param name="pattern" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; string.wildmatch() performs a shell-like wild match on the supplied string. The pattern may contain the wildcard characters '?' (which matches a single character) and '*' (which matches any substring). &lt;/p&gt;&lt;p&gt; It returns 1 if matched, and 0 otherwise. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="string.regexmatch" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="string.gmtime">
         <description>Time parsing functions.</description>
         <functions>
            <func name="string.gmtime.parse">
               <parameters min="1" max="1" regex=".">
                  <param name="str" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
               </restrictions>
               <description>&lt;p&gt; string.gmtime.parse() parses the supplied string as a time stamp and returns the time in seconds since the epoch (1st Jan 1970). Dates before the epoch or after 2038 will produce unexpected results. &lt;/p&gt;&lt;p&gt; Note: Timezone information contained inside the time string is ignored. The time is always assumed to be in GMT. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.gmtime.format" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="sys">
         <description>Functions relating to the local machine.</description>
         <functions>
            <func name="sys.domainname">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.domainname() returns the domain name of the host machine. For example, if the machine is named 'server1.example.com', sys.domainname() will return 'example.com'. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.hostname" />
               </relatedFunctions>
            </func>
            <func name="sys.getenv">
               <parameters min="1" max="1" regex=".">
                  <param name="variable" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.getenv() returns the named environment variable, or the empty string if the environment variable does not exists. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="sys.getpid">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.getpid() returns the process id of the current process. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
            <func name="sys.hostname">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.hostname() returns the hostname of the host machine. For example, if the machine is named 'server1.example.com', sys.hostname() will return 'server1'. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.domainname" />
               </relatedFunctions>
            </func>
            <func name="sys.time">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time() returns the current system time as the number of seconds since midnight, 1/1/1970. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.timeToString" />
                  <related func="sys.localtime.format" />
                  <related func="sys.gmtime.format" />
                  <related func="sys.time.highres" />
               </relatedFunctions>
            </func>
            <func name="sys.timeToString">
               <parameters min="1" max="1" regex=".">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.timeToString() takes the time in seconds since midnight, 1/1/1970 and if the optional unixtime parameter is provided, returns a formatted string representing that time. If the unixtime parameter is not given, it returns the current time as a formatted string. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="sys.gmtime">
         <description>Date functions using Greenwich Mean Time.</description>
         <functions>
            <func name="sys.gmtime.format">
               <parameters min="1" max="2" regex="..?">
                  <param name="format" />
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.gmtime.format() converts the time into a string format. This function converts using GM time - see sys.localtime.format() to convert using localtime. &lt;p&gt; &lt;table border=1 cellspacing=0 cellpadding=0&gt; &lt;tr&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Meaning&lt;/th&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Meaning&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%a&lt;/td&gt;&lt;td&gt;Mon Tue Wed ...&lt;/td&gt;&lt;td&gt;%A&lt;/td&gt;&lt;td&gt;Monday Tuesday ...&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%b&lt;/td&gt;&lt;td&gt;Jan Feb Mar ...&lt;/td&gt;&lt;td&gt;%B&lt;/td&gt;&lt;td&gt;January February ...&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;Day of month "01"-"31"&lt;/td&gt;&lt;td&gt;%D&lt;/td&gt;&lt;td&gt;%m/%d/%y&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%e&lt;/td&gt;&lt;td&gt;Day of month " 1"-"31"&lt;/td&gt;&lt;td&gt;%H&lt;/td&gt;&lt;td&gt;Hour of day "00-23"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%h&lt;/td&gt;&lt;td&gt;Equivalent to %b&lt;/td&gt;&lt;td&gt;%I&lt;/td&gt;&lt;td&gt;Hour of day "01" - "12"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%j&lt;/td&gt;&lt;td&gt;Julian day of the year "001" to "366"&lt;/td&gt;&lt;td&gt;%m&lt;/td&gt;&lt;td&gt;Month of year "01" - "12"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%M&lt;/td&gt;&lt;td&gt;Minute "00" - "59"&lt;/td&gt;&lt;td&gt;%n&lt;/td&gt;&lt;td&gt;Newline character&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%p&lt;/td&gt;&lt;td&gt;AM/PM&lt;/td&gt;&lt;td&gt;%r&lt;/td&gt;&lt;td&gt;Time in %I:%M:%S [AM|PM]&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%R&lt;/td&gt;&lt;td&gt;%H:%M&lt;/td&gt;&lt;td&gt;%S&lt;/td&gt;&lt;td&gt;Seconds, output as a number between "00" and "61"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%t&lt;/td&gt;&lt;td&gt;Tab character&lt;/td&gt;&lt;td&gt;%T&lt;/td&gt;&lt;td&gt;%H:%M:%S&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%u&lt;/td&gt;&lt;td&gt;Day of week (1 = Monday, 7 = Sunday)&lt;/td&gt;&lt;td&gt;%w&lt;/td&gt;&lt;td&gt;Day of week (0 = Sunday, 6 = Saturday)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%y&lt;/td&gt;&lt;td&gt;Year (without century) "00" to "99"&lt;/td&gt;&lt;td&gt;%Y&lt;/td&gt;&lt;td&gt;Year "0000" to "9999"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%Z&lt;/td&gt;&lt;td&gt;Time zone ("GMT")&lt;/td&gt;&lt;td&gt;%%&lt;/td&gt;&lt;td&gt;"%"&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;p&gt; If supplied, the optional 'unixtime' parameter specifies the number of seconds since midnight 1/1/1970, and the function returns a formatted string representing that time. If the 'unixtime' value is not provided, the current time will be returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.time.yearday" />
                  <related func="sys.localtime.format" />
                  <related func="string.gmtime.parse" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="sys.localtime">
         <description>Date functions using the local time of the system.</description>
         <functions>
            <func name="sys.localtime.format">
               <parameters min="1" max="2" regex="..?">
                  <param name="format" />
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.localtime.format() converts the time into a string format. This function converts using localtime - see sys.gmtime.format() to convert using GMT. &lt;p&gt; &lt;table border=1 cellspacing=0 cellpadding=0&gt; &lt;tr&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Meaning&lt;/th&gt;&lt;th&gt;Format&lt;/th&gt;&lt;th&gt;Meaning&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%a&lt;/td&gt;&lt;td&gt;Mon Tue Wed ...&lt;/td&gt;&lt;td&gt;%A&lt;/td&gt;&lt;td&gt;Monday Tuesday ...&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%b&lt;/td&gt;&lt;td&gt;Jan Feb Mar ...&lt;/td&gt;&lt;td&gt;%B&lt;/td&gt;&lt;td&gt;January February ...&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;Day of month "01"-"31"&lt;/td&gt;&lt;td&gt;%D&lt;/td&gt;&lt;td&gt;%m/%d/%y&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%e&lt;/td&gt;&lt;td&gt;Day of month " 1"-"31"&lt;/td&gt;&lt;td&gt;%H&lt;/td&gt;&lt;td&gt;Hour of day "00-23"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%h&lt;/td&gt;&lt;td&gt;Equivalent to %b&lt;/td&gt;&lt;td&gt;%I&lt;/td&gt;&lt;td&gt;Hour of day "01" - "12"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%j&lt;/td&gt;&lt;td&gt;Julian day of the year "001" to "366"&lt;/td&gt;&lt;td&gt;%m&lt;/td&gt;&lt;td&gt;Month of year "01" - "12"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%M&lt;/td&gt;&lt;td&gt;Minute "00" - "59"&lt;/td&gt;&lt;td&gt;%n&lt;/td&gt;&lt;td&gt;Newline character&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%p&lt;/td&gt;&lt;td&gt;AM/PM&lt;/td&gt;&lt;td&gt;%r&lt;/td&gt;&lt;td&gt;Time in %I:%M:%S [AM|PM]&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%R&lt;/td&gt;&lt;td&gt;%H:%M&lt;/td&gt;&lt;td&gt;%S&lt;/td&gt;&lt;td&gt;Seconds, output as a number between "00" and "61"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%t&lt;/td&gt;&lt;td&gt;Tab character&lt;/td&gt;&lt;td&gt;%T&lt;/td&gt;&lt;td&gt;%H:%M:%S&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%u&lt;/td&gt;&lt;td&gt;Day of week (1 = Monday, 7 = Sunday)&lt;/td&gt;&lt;td&gt;%w&lt;/td&gt;&lt;td&gt;Day of week (0 = Sunday, 6 = Saturday)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%y&lt;/td&gt;&lt;td&gt;Year (without century) "00" to "99"&lt;/td&gt;&lt;td&gt;%Y&lt;/td&gt;&lt;td&gt;Year "0000" to "9999"&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;%Z&lt;/td&gt;&lt;td&gt;Time zone (from $TZ)&lt;/td&gt;&lt;td&gt;%%&lt;/td&gt;&lt;td&gt;"%"&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;p&gt; If supplied, the optional 'unixtime' parameter specifies the number of seconds since midnight 1/1/1970, and the function returns a formatted string representing that time. If the 'unixtime' value is not provided, the current time will be returned. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.time.yearday" />
                  <related func="sys.gmtime.format" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="sys.time">
         <description>General date functions.</description>
         <functions>
            <func name="sys.time.highres">
               <parameters min="0" max="0" regex=""></parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.highres() returns the current system time as the number of seconds and microseconds since midnight, 1/1/1970. The value is returned as a double, e.g. 1138417190.823265 &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.timeToString" />
                  <related func="sys.localtime.format" />
                  <related func="sys.gmtime.format" />
                  <related func="sys.time" />
               </relatedFunctions>
            </func>
            <func name="sys.time.hour">
               <parameters min="0" max="1" regex=".?">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.hour() returns the hour of the day in local time (0-23). &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.yearday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
            <func name="sys.time.minutes">
               <parameters min="0" max="1" regex=".?">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.minutes() returns the minutes after the hour in local time (0-59). &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.yearday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
            <func name="sys.time.month">
               <parameters min="0" max="1" regex=".?">
                  <param name="value" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.month() returns the month of the year in local time (1-12). &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.yearday" />
                  <related func="sys.time.year" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
            <func name="sys.time.monthday">
               <parameters min="0" max="1" regex=".?">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.monthday() returns the day of the month in local time (1-31). &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.yearday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
            <func name="sys.time.seconds">
               <parameters min="0" max="1" regex=".?">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.seconds() returns the seconds after the minute in local time. Normally, it returns a number in the range of (0-59), but can be up to 61 to allow for leap seconds. &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.yearday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
            <func name="sys.time.weekday">
               <parameters min="0" max="1" regex=".?">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.weekday() returns the day of the week in local time (1-7). Sunday has the value 1; Saturday has the value 7. &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.yearday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
            <func name="sys.time.year">
               <parameters min="0" max="1" regex=".?">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.year() returns the year in local time (1970-2038). &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.yearday" />
                  <related func="sys.time.month" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
            <func name="sys.time.yearday">
               <parameters min="0" max="1" regex=".?">
                  <param name="unixtime" />
               </parameters>
               <restrictions>
                  <restriction type="FEATURE_CORE" />
                  <restriction type="FEATURE_SHORTCUT" />
               </restrictions>
               <description>&lt;p&gt; sys.time.yearday() returns the day of the year in local time (1-366). &lt;p&gt; If optional parameter 'unixtime' is supplied, then this specifies the time since midnight 1/1/1970 otherwise the current time will be used. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="sys.time" />
                  <related func="sys.time.seconds" />
                  <related func="sys.time.minutes" />
                  <related func="sys.time.hour" />
                  <related func="sys.time.weekday" />
                  <related func="sys.time.monthday" />
                  <related func="sys.time.month" />
                  <related func="sys.time.year" />
                  <related func="sys.localtime.format" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="xml">
         <description>Functions for parsing and manipulating the eXtensible Markup Language.</description>
         <functions>
            <func name="xml.validate">
               <parameters min="2" max="2" regex="..">
                  <param name="document" />
                  <param name="DTD" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_XML" />
                  <restriction type="FEATURE_DEPRECATED" />
               </restrictions>
               <description>&lt;p&gt; xml.validate() validates an XML document against a DTD. It returns 1 if the document validated correctly, and 0 if it did not. It returns -1 if there was an error parsing the XML document or the DTD. &lt;/p&gt;&lt;p&gt; The xml-processing functionality must be enabled by the software license. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Function is deprecated.&lt;/b&gt;&lt;br /&gt;Replaced by xml.validate.dtd&lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="xml.validate">
         <description>Functions for validating the eXtensible Markup Language.</description>
         <functions>
            <func name="xml.validate.dtd">
               <parameters min="2" max="2" regex="..">
                  <param name="document" />
                  <param name="DTD" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_XML" />
               </restrictions>
               <description>&lt;p&gt; xml.validate.dtd() validates an XML document against a DTD. It returns 1 if the document validated correctly, and 0 if it did not. It returns -1 if there was an error parsing the XML document or the DTD. &lt;/p&gt;&lt;p&gt; The xml-processing functionality must be enabled by the software license. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="xml.validate.xsd" />
               </relatedFunctions>
            </func>
            <func name="xml.validate.xsd">
               <parameters min="2" max="2" regex="..">
                  <param name="document" />
                  <param name="schema" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_XML" />
               </restrictions>
               <description>&lt;p&gt; xml.validate.xsd() validates an XML document against an XML schema. It returns 1 if the document validated correctly, and 0 if it did not. It returns -1 if there was an error parsing the XML document or the schema. &lt;/p&gt;&lt;p&gt; The xml-processing functionality must be enabled by the software license. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="xml.validate.dtd" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="xml.xpath">
         <description>Functions for preforming XPath queries on XML data.</description>
         <functions>
            <func name="xml.xpath.matchNodeCount">
               <parameters min="3" max="3" regex="...">
                  <param name="doc" />
                  <param name="nspace" />
                  <param name="query" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_XML" />
               </restrictions>
               <description>&lt;p&gt; xml.xpath.matchNodeCount() applies an XPath query to an XML document (doc), using the namespaces provided in nspace. It returns the number of entries in the result node set. &lt;/p&gt;&lt;p&gt; It returns -1 if there was an error parsing the XML document, XML namespace or XPath query. &lt;/p&gt;&lt;p&gt; The xml-processing functionality must be enabled by the software license. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="xml.xpath.matchNodeSet" />
               </relatedFunctions>
            </func>
            <func name="xml.xpath.matchNodeSet">
               <parameters min="3" max="3" regex="...">
                  <param name="doc" />
                  <param name="nspace" />
                  <param name="query" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_XML" />
               </restrictions>
               <description>&lt;p&gt; xml.xpath.matchNodeSet() applies an XPath query to an XML document (doc), using the namespaces provided in nspace. It returns a string representation of the result node set. &lt;/p&gt;&lt;p&gt; It returns the empty string if there was an error parsing the XML document, XML namespace or XPath query. &lt;/p&gt;&lt;p&gt; The xml-processing functionality must be enabled by the software license. &lt;/p&gt;</description>
               <relatedFunctions>
                  <related func="xml.xpath.matchNodeCount" />
               </relatedFunctions>
            </func>
         </functions>
      </group>
      <group name="xml.xslt">
         <description>XSLT transformation functions.</description>
         <functions>
            <func name="xml.xslt.transform">
               <parameters min="2" max="2" regex="..">
                  <param name="document" />
                  <param name="stylesheet" />
               </parameters>
               <restrictions>
                  <restriction type="ZXTM_XML" />
               </restrictions>
               <description>&lt;p&gt; xml.xslt.transform() performs an XSLT transformation on a XML document. It returns the transformed document, or -1 on failure. &lt;/p&gt;&lt;p&gt; The xml-processing functionality must be enabled by the software license. &lt;/p&gt;</description>
               <relatedFunctions></relatedFunctions>
            </func>
         </functions>
      </group>
   </groups>
</codedata>
